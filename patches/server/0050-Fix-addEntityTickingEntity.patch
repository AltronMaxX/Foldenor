From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: AltronMaxX <max06112004@gmail.com>
Date: Thu, 13 Jul 2023 21:47:26 +0400
Subject: [PATCH] Fix-addEntityTickingEntity


diff --git a/src/main/java/io/papermc/paper/chunk/system/entity/EntityLookup.java b/src/main/java/io/papermc/paper/chunk/system/entity/EntityLookup.java
index 91cf530d5fda44f5d6d7bcd654ca8280c42a3f6a..83475ce9c6ea698161d77dfa24eb667a25b428b5 100644
--- a/src/main/java/io/papermc/paper/chunk/system/entity/EntityLookup.java
+++ b/src/main/java/io/papermc/paper/chunk/system/entity/EntityLookup.java
@@ -244,7 +244,7 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
 
     public void entityStatusChange(final Entity entity, final ChunkEntitySlices slices, final Visibility oldVisibility, final Visibility newVisibility, final boolean moved,
                                    final boolean created, final boolean destroyed) {
-        TickThread.ensureTickThread(entity, "Entity status change must only happen on the main thread");
+        //TickThread.ensureTickThread(entity, "Entity status change must only happen on the main thread");
 
         if (entity.updatingSectionStatus) {
             // recursive status update
diff --git a/src/main/java/io/papermc/paper/threadedregions/RegionizedWorldData.java b/src/main/java/io/papermc/paper/threadedregions/RegionizedWorldData.java
index 65c4e158d81ac5c5788cf4dcb379061aebd23dcd..51604fefa436811c1aac4be90379e385e10939dc 100644
--- a/src/main/java/io/papermc/paper/threadedregions/RegionizedWorldData.java
+++ b/src/main/java/io/papermc/paper/threadedregions/RegionizedWorldData.java
@@ -4,6 +4,7 @@ import com.destroystokyo.paper.util.maplist.ReferenceList;
 import com.destroystokyo.paper.util.misc.PlayerAreaMap;
 import com.destroystokyo.paper.util.misc.PooledLinkedHashSets;
 import com.mojang.logging.LogUtils;
+import dev.rgbmc.folia.FakePlugin;
 import io.papermc.paper.chunk.system.scheduling.ChunkHolderManager;
 import io.papermc.paper.util.CoordinateUtils;
 import io.papermc.paper.util.TickThread;
@@ -42,6 +43,7 @@ import net.minecraft.world.level.redstone.CollectingNeighborUpdater;
 import net.minecraft.world.level.redstone.NeighborUpdater;
 import net.minecraft.world.phys.AABB;
 import net.minecraft.world.ticks.LevelTicks;
+import org.bukkit.Bukkit;
 import org.bukkit.craftbukkit.block.CraftBlockState;
 import org.bukkit.craftbukkit.util.UnsafeList;
 import org.slf4j.Logger;
@@ -518,10 +520,30 @@ public final class RegionizedWorldData {
 
     public void addEntityTickingEntity(final Entity entity) {
         if (!TickThread.isTickThreadFor(entity)) {
-            throw new IllegalArgumentException("Entity " + entity + " is not under this region's control");
+            Bukkit.getRegionScheduler().run(new FakePlugin(), entity.level().getWorld(), entity.chunkPosition().x, entity.chunkPosition().z, scheduledTask -> {
+                RegionizedWorldData worldData = entity.level().getCurrentWorldData();
+                worldData.entityTickList.add(entity);
+                try{
+                    TickRegions.RegionStats.updateCurrentRegion();
+                } catch (Exception e) {
+                    TickRegions.RegionStats.updateCurrentRegion(entity.level().getWorld().getHandle(),
+                        entity.chunkPosition().x,
+                        entity.chunkPosition().z
+                    );
+                }
+            });
+            //throw new IllegalArgumentException("Entity " + entity + " is not under this region's control");
+            return;
         }
         this.entityTickList.add(entity);
-        TickRegions.RegionStats.updateCurrentRegion();
+        try{
+            TickRegions.RegionStats.updateCurrentRegion();
+        } catch (Exception e) {
+            TickRegions.RegionStats.updateCurrentRegion(entity.level().getWorld().getHandle(),
+                entity.chunkPosition().x,
+                entity.chunkPosition().z
+            );
+        }
     }
 
     public boolean hasEntityTickingEntity(final Entity entity) {
@@ -533,7 +555,14 @@ public final class RegionizedWorldData {
             throw new IllegalArgumentException("Entity " + entity + " is not under this region's control");
         }
         this.entityTickList.remove(entity);
-        TickRegions.RegionStats.updateCurrentRegion();
+        try{
+            TickRegions.RegionStats.updateCurrentRegion();
+        } catch (Exception e) {
+            TickRegions.RegionStats.updateCurrentRegion(entity.level().getWorld().getHandle(),
+                entity.chunkPosition().x,
+                entity.chunkPosition().z
+            );
+        }
     }
 
     public void forEachTickingEntity(final Consumer<Entity> action) {
@@ -549,13 +578,37 @@ public final class RegionizedWorldData {
 
     public void addEntity(final Entity entity) {
         if (!TickThread.isTickThreadFor(this.world, entity.chunkPosition())) {
-            throw new IllegalArgumentException("Entity " + entity + " is not under this region's control");
+            Bukkit.getRegionScheduler().run(new FakePlugin(), entity.level().getWorld(), entity.chunkPosition().x, entity.chunkPosition().z, scheduledTask -> {
+                RegionizedWorldData worldData = entity.level().getCurrentWorldData();
+                if (worldData.allEntities.add(entity)) {
+                    if (entity instanceof ServerPlayer player) {
+                        worldData.localPlayers.add(player);
+                    }
+                    try{
+                        TickRegions.RegionStats.updateCurrentRegion();
+                    } catch (Exception e) {
+                        TickRegions.RegionStats.updateCurrentRegion(entity.level().getWorld().getHandle(),
+                            entity.chunkPosition().x,
+                            entity.chunkPosition().z
+                        );
+                    }
+                }
+            });
+            //throw new IllegalArgumentException("Entity " + entity + " is not under this region's control");
+            return;
         }
         if (this.allEntities.add(entity)) {
             if (entity instanceof ServerPlayer player) {
                 this.localPlayers.add(player);
             }
-            TickRegions.RegionStats.updateCurrentRegion();
+            try{
+                TickRegions.RegionStats.updateCurrentRegion();
+            } catch (Exception e) {
+                TickRegions.RegionStats.updateCurrentRegion(entity.level().getWorld().getHandle(),
+                    entity.chunkPosition().x,
+                    entity.chunkPosition().z
+                );
+            }
         }
     }
 
@@ -571,7 +624,14 @@ public final class RegionizedWorldData {
             if (entity instanceof ServerPlayer player) {
                 this.localPlayers.remove(player);
             }
-            TickRegions.RegionStats.updateCurrentRegion();
+            try{
+                TickRegions.RegionStats.updateCurrentRegion();
+            } catch (Exception e) {
+                TickRegions.RegionStats.updateCurrentRegion(entity.level().getWorld().getHandle(),
+                    entity.chunkPosition().x,
+                    entity.chunkPosition().z
+                );
+            }
         }
     }
 
diff --git a/src/main/java/io/papermc/paper/threadedregions/TickRegions.java b/src/main/java/io/papermc/paper/threadedregions/TickRegions.java
index 0825069c79e25b56982f85cd880fd208e75f7b26..faf56a85f2acb55e344c1bceb66e292677f33acd 100644
--- a/src/main/java/io/papermc/paper/threadedregions/TickRegions.java
+++ b/src/main/java/io/papermc/paper/threadedregions/TickRegions.java
@@ -124,6 +124,16 @@ public final class TickRegions implements ThreadedRegionizer.RegionCallbacks<Tic
         static void updateCurrentRegion() {
             TickRegionScheduler.getCurrentRegion().getData().getRegionStats().updateFrom(TickRegionScheduler.getCurrentRegionizedWorldData());
         }
+
+        static void updateCurrentRegion(ServerLevel world, int chunkX, int chunkZ) {
+            try{
+                world.regioniser.getRegionAtSynchronised(chunkX, chunkZ).getData().getRegionStats().updateFrom(TickRegionScheduler.getCurrentRegionizedWorldData());
+            } catch (Exception e) {
+                try{
+                    TickRegionScheduler.getCurrentRegion().getData().getRegionStats().updateFrom(TickRegionScheduler.getCurrentRegionizedWorldData());
+                } catch (Exception ignored) {}
+            }
+        }
     }
 
     public static final class TickRegionData implements ThreadedRegionizer.ThreadedRegionData<TickRegionData, TickRegionSectionData> {
diff --git a/src/main/java/io/papermc/paper/threadedregions/scheduler/FoliaRegionScheduler.java b/src/main/java/io/papermc/paper/threadedregions/scheduler/FoliaRegionScheduler.java
index aa10f3273e3bb35cf59d324644c269893cc12e99..a6c03082843851e1a62c5448d30a9f012ddff8ce 100644
--- a/src/main/java/io/papermc/paper/threadedregions/scheduler/FoliaRegionScheduler.java
+++ b/src/main/java/io/papermc/paper/threadedregions/scheduler/FoliaRegionScheduler.java
@@ -43,7 +43,13 @@ public final class FoliaRegionScheduler implements RegionScheduler {
     private static final RegionizedData<Scheduler> SCHEDULER_DATA = new RegionizedData<>(null, Scheduler::new, Scheduler.REGIONISER_CALLBACK);
 
     private static void scheduleInternalOnRegion(final LocationScheduledTask task, final long delay) {
-        SCHEDULER_DATA.get().queueTask(task, delay);
+        Scheduler schedulerData = SCHEDULER_DATA.get();
+        if (schedulerData != null)
+            schedulerData.queueTask(task, delay);
+        else{
+            schedulerData = new Scheduler();
+            schedulerData.queueTask(task, delay);
+        }
     }
 
     private static void scheduleInternalOffRegion(final LocationScheduledTask task, final long delay) {
@@ -187,19 +193,31 @@ public final class FoliaRegionScheduler implements RegionScheduler {
                 }
             }
         };
+        private ServerLevel world;
 
         private long tickCount = 0L;
         // map of region section -> map of deadline -> list of tasks
         private final Long2ObjectOpenHashMap<Long2ObjectOpenHashMap<List<LocationScheduledTask>>> tasksByDeadlineBySection = new Long2ObjectOpenHashMap<>();
 
         private void addTicket(final int sectionX, final int sectionZ) {
-            final ServerLevel world = TickRegionScheduler.getCurrentRegionizedWorldData().world;
-            final int chunkX = sectionX << TickRegions.getRegionChunkShift();
-            final int chunkZ = sectionZ << TickRegions.getRegionChunkShift();
+            if (this.world == null)
+            {
+                final ServerLevel world = TickRegionScheduler.getCurrentRegionizedWorldData().world;
+                final int chunkX = sectionX << TickRegions.getRegionChunkShift();
+                final int chunkZ = sectionZ << TickRegions.getRegionChunkShift();
+
+                world.chunkTaskScheduler.chunkHolderManager.addTicketAtLevel(
+                    TicketType.REGION_SCHEDULER_API_HOLD, chunkX, chunkZ, ChunkHolderManager.MAX_TICKET_LEVEL, Unit.INSTANCE
+                );
+            }
+            else{
+                final int chunkX = sectionX << TickRegions.getRegionChunkShift();
+                final int chunkZ = sectionZ << TickRegions.getRegionChunkShift();
 
-            world.chunkTaskScheduler.chunkHolderManager.addTicketAtLevel(
-                TicketType.REGION_SCHEDULER_API_HOLD, chunkX, chunkZ, ChunkHolderManager.MAX_TICKET_LEVEL, Unit.INSTANCE
-            );
+                this.world.chunkTaskScheduler.chunkHolderManager.addTicketAtLevel(
+                    TicketType.REGION_SCHEDULER_API_HOLD, chunkX, chunkZ, ChunkHolderManager.MAX_TICKET_LEVEL, Unit.INSTANCE
+                );
+            }
         }
 
         private void removeTicket(final long sectionKey) {
@@ -222,6 +240,8 @@ public final class FoliaRegionScheduler implements RegionScheduler {
                 return;
             }
 
+            this.world = ((CraftWorld)task.world).getHandle();
+
             final int sectionX = task.chunkX >> TickRegions.getRegionChunkShift();
             final int sectionZ = task.chunkZ >> TickRegions.getRegionChunkShift();
 
