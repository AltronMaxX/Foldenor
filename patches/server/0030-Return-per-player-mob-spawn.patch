From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: AltronMaxX <max06112004@gmail.com>
Date: Sun, 2 Jul 2023 01:01:57 +0400
Subject: [PATCH] Return-per-player-mob-spawn


diff --git a/src/main/java/io/papermc/paper/command/PaperCommand.java b/src/main/java/io/papermc/paper/command/PaperCommand.java
index dc1820e1231c15a7244883731a86f04fa8d20aa1..248a99c09f4dce5c627ae479e5d0844f7c2e505d 100644
--- a/src/main/java/io/papermc/paper/command/PaperCommand.java
+++ b/src/main/java/io/papermc/paper/command/PaperCommand.java
@@ -43,7 +43,8 @@ public final class PaperCommand extends Command {
         commands.put(Set.of("debug", "chunkinfo", "holderinfo"), new ChunkDebugCommand());
         commands.put(Set.of("syncloadinfo"), new SyncLoadInfoCommand());
         commands.put(Set.of("dumpitem"), new DumpItemCommand());
-        commands.put(Set.of("mobcaps"), new MobcapsCommand()); // Folia - region threading - revert per player mob caps
+        commands.put(Set.of("mobcaps", "playermobcaps"), new MobcapsCommand());
+        //commands.put(Set.of("mobcaps"), new MobcapsCommand()); // Folia - region threading - revert per player mob caps
         commands.put(Set.of("dumplisteners"), new DumpListenersCommand());
 
         return commands.entrySet().stream()
diff --git a/src/main/java/io/papermc/paper/command/subcommands/MobcapsCommand.java b/src/main/java/io/papermc/paper/command/subcommands/MobcapsCommand.java
index 41aaa709dc2e474f23e759ebc51f33021c4f5485..961c350bf34a77aa14636f3ff71c0a2fdc21b2cc 100644
--- a/src/main/java/io/papermc/paper/command/subcommands/MobcapsCommand.java
+++ b/src/main/java/io/papermc/paper/command/subcommands/MobcapsCommand.java
@@ -46,7 +46,7 @@ public final class MobcapsCommand implements PaperSubcommand {
     public boolean execute(final CommandSender sender, final String subCommand, final String[] args) {
         switch (subCommand) {
             case "mobcaps" -> this.printMobcaps(sender, args);
-            //case "playermobcaps" -> this.printPlayerMobcaps(sender, args); // Folia - region threading - revert per player mob caps
+            case "playermobcaps" -> this.printPlayerMobcaps(sender, args); // Folia - region threading - revert per player mob caps
         }
         return true;
     }
@@ -55,7 +55,7 @@ public final class MobcapsCommand implements PaperSubcommand {
     public List<String> tabComplete(final CommandSender sender, final String subCommand, final String[] args) {
         return switch (subCommand) {
             case "mobcaps" -> CommandUtil.getListMatchingLast(sender, args, this.suggestMobcaps(args));
-            //case "playermobcaps" -> CommandUtil.getListMatchingLast(sender, args, this.suggestPlayerMobcaps(sender, args)); // Folia - region threading - revert per player mob caps
+            case "playermobcaps" -> CommandUtil.getListMatchingLast(sender, args, this.suggestPlayerMobcaps(sender, args)); // Folia - region threading - revert per player mob caps
             default -> throw new IllegalArgumentException();
         };
     }
@@ -140,6 +140,42 @@ public final class MobcapsCommand implements PaperSubcommand {
         }
     }
 
+    private void printPlayerMobcaps(final CommandSender sender, final String[] args) {
+        final @Nullable Player player;
+        if (args.length == 0) {
+            if (sender instanceof Player pl) {
+                player = pl;
+            } else {
+                sender.sendMessage(Component.text("Must specify a player! ex: '/paper playermobcount playerName'", NamedTextColor.RED));
+                return;
+            }
+        } else if (args.length == 1) {
+            final String input = args[0];
+            player = Bukkit.getPlayerExact(input);
+            if (player == null) {
+                sender.sendMessage(Component.text("Could not find player named '" + input + "'", NamedTextColor.RED));
+                return;
+            }
+        } else {
+            sender.sendMessage(Component.text("Too many arguments!", NamedTextColor.RED));
+            return;
+        }
+
+        final ServerPlayer serverPlayer = ((CraftPlayer) player).getHandle();
+        final ServerLevel level = serverPlayer.serverLevel();
+
+        if (!level.paperConfig().entities.spawning.perPlayerMobSpawns) {
+            sender.sendMessage(Component.text("Use '/paper mobcaps' for worlds where per-player mob spawning is disabled.", NamedTextColor.RED));
+            return;
+        }
+
+        sender.sendMessage(Component.join(JoinConfiguration.noSeparators(), Component.text("Mobcaps for player: "), Component.text(player.getName(), NamedTextColor.GREEN)));
+        sender.sendMessage(createMobcapsComponent(
+            category -> level.chunkSource.chunkMap.getMobCountNear(serverPlayer, category),
+            category -> level.getWorld().getSpawnLimitUnsafe(org.bukkit.craftbukkit.util.CraftSpawnCategory.toBukkit(category))
+        ));
+    }
+
     // Folia - region threading - revert per player mob caps
 
     private static Component createMobcapsComponent(final ToIntFunction<MobCategory> countGetter, final ToIntFunction<MobCategory> limitGetter) {
diff --git a/src/main/java/io/papermc/paper/configuration/WorldConfiguration.java b/src/main/java/io/papermc/paper/configuration/WorldConfiguration.java
index a00201eca053ef69b8d903fdb9538444baf85465..dcd9aa7c525c0e701d14ad9d6ae2bdc2cdbcd72a 100644
--- a/src/main/java/io/papermc/paper/configuration/WorldConfiguration.java
+++ b/src/main/java/io/papermc/paper/configuration/WorldConfiguration.java
@@ -134,7 +134,7 @@ public class WorldConfiguration extends ConfigurationPart {
             public boolean filterBadTileEntityNbtFromFallingBlocks = true;
             public List<NbtPathArgument.NbtPath> filteredEntityTagNbtPaths = NbtPathSerializer.fromString(List.of("Pos", "Motion", "SleepingX", "SleepingY", "SleepingZ"));
             public boolean disableMobSpawnerSpawnEggTransformation = false;
-            //public boolean perPlayerMobSpawns = true; // Folia - region threading - revert per player mob caps
+            public boolean perPlayerMobSpawns = true; // Folia - region threading - revert per player mob caps
             public boolean scanForLegacyEnderDragon = true;
             @MergeMap
             public Reference2IntMap<MobCategory> spawnLimits = Util.make(new Reference2IntOpenHashMap<>(NaturalSpawner.SPAWNING_CATEGORIES.length), map -> Arrays.stream(NaturalSpawner.SPAWNING_CATEGORIES).forEach(mobCategory -> map.put(mobCategory, -1)));
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 7c8a64a070c5c754c97cc4991fa7b2c4bd36a38e..3cea93b497b3a21d91ab37f1967ca49b64ebcfb3 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -357,6 +357,15 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
 
     // Paper start
+    public void updatePlayerMobTypeMap(Entity entity) {
+        if (!this.level.paperConfig().entities.spawning.perPlayerMobSpawns) {
+            return;
+        }
+    }
+
+    public int getMobCountNear(ServerPlayer entityPlayer, net.minecraft.world.entity.MobCategory mobCategory) {
+        return entityPlayer.mobCounts[mobCategory.ordinal()];
+    }
     // Folia - region threading - revert per player mob caps
     // Paper end
 
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index 865b8c9631605a6270e014459bf9e8c2bcdf6aa7..cd536d5335224f95d3dbf1063fc14a83cac97d49 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -516,8 +516,16 @@ public class ServerChunkCache extends ChunkSource {
             int l = this.distanceManager.getNaturalSpawnChunkCount();
             // Paper start - per player mob spawning
             NaturalSpawner.SpawnState spawnercreature_d; // moved down
+            if ((this.spawnFriendlies || this.spawnEnemies)) {
+                for (ServerPlayer player : this.level.players) {
+                      Arrays.fill(player.mobCounts, 0);
+                }
+                spawnercreature_d = NaturalSpawner.createState(l, regionizedWorldData.getLocalEntities(), this::getFullChunk, null, true); // Folia - region threading
+            } else{
+                spawnercreature_d = NaturalSpawner.createState(l, regionizedWorldData.getLocalEntities(), this::getFullChunk, new LocalMobCapCalculator(this.chunkMap), false); // Folia - region threading
+            }
             // Folia start - threaded regions - revert per-player mob caps
-            spawnercreature_d = this.spawnFriendlies || this.spawnEnemies ? NaturalSpawner.createState(l, regionizedWorldData.getLocalEntities(), this::getFullChunk, new LocalMobCapCalculator(this.chunkMap)) : null; // Folia - region threading
+            //spawnercreature_d = this.spawnFriendlies || this.spawnEnemies ? NaturalSpawner.createState(l, regionizedWorldData.getLocalEntities(), this::getFullChunk, new LocalMobCapCalculator(this.chunkMap)) : null; // Folia - region threading
             // Folia end - threaded regions - revert per-player mob caps
             this.level.timings.countNaturalMobs.stopTiming(); // Paper - timings
 
@@ -536,7 +544,7 @@ public class ServerChunkCache extends ChunkSource {
 
             // Paper start - optimise chunk tick iteratio
             Iterator<LevelChunk> iterator1;
-            if (true) { // Folia - region threading - revert per player mob caps, except for this - WTF are they doing?
+            if (this.level.paperConfig().entities.spawning.perPlayerMobSpawns) { // Folia - region threading - revert per player mob caps, except for this - WTF are they doing?
                 iterator1 = regionizedWorldData.getEntityTickingChunks().iterator(); // Folia - region threading
             } else {
                 iterator1 = regionizedWorldData.getEntityTickingChunks().unsafeIterator(); // Folia - region threading
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index 817f79bfca1aec161cb4635b9c7a8e21b14db7eb..7f6bddf43263a9cd3e2d21fa08c796f8aacd961d 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -251,6 +251,11 @@ public class ServerPlayer extends Player {
     public boolean queueHealthUpdatePacket = false;
     public net.minecraft.network.protocol.game.ClientboundSetHealthPacket queuedHealthUpdatePacket;
     // Paper end
+    // Paper start - mob spawning rework
+    public static final int MOBCATEGORY_TOTAL_ENUMS = net.minecraft.world.entity.MobCategory.values().length;
+    public final int[] mobCounts = new int[MOBCATEGORY_TOTAL_ENUMS]; // Paper
+    public final com.destroystokyo.paper.util.PooledHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> cachedSingleMobDistanceMap;
+    // Paper end
     // Folia - region threading - revert per player mob caps
 
     // CraftBukkit start
@@ -412,6 +417,7 @@ public class ServerPlayer extends Player {
         this.adventure$displayName = net.kyori.adventure.text.Component.text(this.getScoreboardName()); // Paper
         this.bukkitPickUpLoot = true;
         this.maxHealthCache = this.getMaxHealth();
+        this.cachedSingleMobDistanceMap = new com.destroystokyo.paper.util.PooledHashSets.PooledObjectLinkedOpenHashSet<>(this); // Paper
         // Folia - region threading - revert per player mob caps
     }
 
diff --git a/src/main/java/net/minecraft/world/level/NaturalSpawner.java b/src/main/java/net/minecraft/world/level/NaturalSpawner.java
index 8903a2db824377c2c3232d02f075f4e267a64dbd..d7d118029763b5a2432d20caf25e2addee8cd24a 100644
--- a/src/main/java/net/minecraft/world/level/NaturalSpawner.java
+++ b/src/main/java/net/minecraft/world/level/NaturalSpawner.java
@@ -115,6 +115,11 @@ public final class NaturalSpawner {
                     }
 
                     object2intopenhashmap.addTo(enumcreaturetype, 1);
+                    // Paper start
+                    if (countMobs) {
+                        chunk.level.getChunkSource().chunkMap.updatePlayerMobTypeMap(entity);
+                    }
+                    // Paper end
                     // Folia - rewrite chunk system - revert per player mob caps
                 });
             }
@@ -147,16 +152,23 @@ public final class NaturalSpawner {
             }
 
             if (!spawnThisTick || limit == 0) {
-                continue;
+               continue;
             }
 
-            if ((spawnAnimals || !enumcreaturetype.isFriendly()) && (spawnMonsters || enumcreaturetype.isFriendly()) && (rareSpawn || !enumcreaturetype.isPersistent()) && info.canSpawnForCategory(enumcreaturetype, chunk.getPos(), limit)) { // Folia - region threading - revert per player mob caps
+            // Paper start - only allow spawns upto the limit per chunk and update count afterwards
+            int currEntityCount = info.mobCategoryCounts.getInt(enumcreaturetype);
+            int k1 = limit * info.getSpawnableChunkCount() / NaturalSpawner.MAGIC_NUMBER;
+            int difference = k1 - currEntityCount;
+
+            if ((spawnAnimals || !enumcreaturetype.isFriendly()) && (spawnMonsters || enumcreaturetype.isFriendly()) && (rareSpawn || !enumcreaturetype.isPersistent()) && difference > 0) { // Folia - region threading - revert per player mob caps
                 // CraftBukkit end
                 Objects.requireNonNull(info);
                 NaturalSpawner.SpawnPredicate spawnercreature_c = info::canSpawn;
+                int spawnCount = NaturalSpawner.spawnCategoryForChunk(enumcreaturetype, world, chunk, spawnercreature_c, info::afterSpawn, difference, false && world.paperConfig().entities.spawning.perPlayerMobSpawns ? world.getChunkSource().chunkMap::updatePlayerMobTypeMap : null); // Folia - region threading
 
-                Objects.requireNonNull(info);
-                NaturalSpawner.spawnCategoryForChunk(enumcreaturetype, world, chunk, spawnercreature_c, info::afterSpawn); // Folia - region threading - revert per player mob caps
+                //Objects.requireNonNull(info);
+                info.mobCategoryCounts.mergeInt(enumcreaturetype, spawnCount, Integer::sum);
+                //NaturalSpawner.spawnCategoryForChunk(enumcreaturetype, world, chunk, spawnercreature_c, info::afterSpawn); // Folia - region threading - revert per player mob caps
             }
         }
 
