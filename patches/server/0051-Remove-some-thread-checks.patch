From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: AltronMaxX <max06112004@gmail.com>
Date: Sat, 15 Jul 2023 01:03:18 +0400
Subject: [PATCH] Remove-some-thread-checks


diff --git a/src/main/java/io/papermc/paper/chunk/system/entity/EntityLookup.java b/src/main/java/io/papermc/paper/chunk/system/entity/EntityLookup.java
index 83475ce9c6ea698161d77dfa24eb667a25b428b5..f50eb7b0fd809d5ccbf21022a770f5ed05e6423f 100644
--- a/src/main/java/io/papermc/paper/chunk/system/entity/EntityLookup.java
+++ b/src/main/java/io/papermc/paper/chunk/system/entity/EntityLookup.java
@@ -393,7 +393,7 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
         final int sectionX = pos.getX() >> 4;
         final int sectionY = Mth.clamp(pos.getY() >> 4, this.minSection, this.maxSection);
         final int sectionZ = pos.getZ() >> 4;
-        TickThread.ensureTickThread(this.world, sectionX, sectionZ, "Cannot add entity off-main thread");
+        //TickThread.ensureTickThread(this.world, sectionX, sectionZ, "Cannot add entity off-main thread");
 
         if (entity.isRemoved()) {
             LOGGER.warn("Refusing to add removed entity: " + entity);
@@ -469,7 +469,7 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
         final int sectionX = entity.sectionX;
         final int sectionY = entity.sectionY;
         final int sectionZ = entity.sectionZ;
-        TickThread.ensureTickThread(this.world, sectionX, sectionZ, "Cannot remove entity off-main");
+        //TickThread.ensureTickThread(this.world, sectionX, sectionZ, "Cannot remove entity off-main");
         if (!entity.isRemoved()) {
             throw new IllegalStateException("Only call Entity#setRemoved to remove an entity");
         }
@@ -500,7 +500,7 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
 
     private ChunkEntitySlices moveEntity(final Entity entity) {
         // ensure we own the entity
-        TickThread.ensureTickThread(entity, "Cannot move entity off-main");
+        //TickThread.ensureTickThread(entity, "Cannot move entity off-main");
 
         final BlockPos newPos = entity.blockPosition();
         final int newSectionX = newPos.getX() >> 4;
@@ -512,10 +512,10 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
         }
 
         // ensure the new section is owned by this tick thread
-        TickThread.ensureTickThread(this.world, newSectionX, newSectionZ, "Cannot move entity off-main");
+       // TickThread.ensureTickThread(this.world, newSectionX, newSectionZ, "Cannot move entity off-main");
 
         // ensure the old section is owned by this tick thread
-        TickThread.ensureTickThread(this.world, entity.sectionX, entity.sectionZ, "Cannot move entity off-main");
+        //TickThread.ensureTickThread(this.world, entity.sectionX, entity.sectionZ, "Cannot move entity off-main");
 
         final ChunkEntitySlices old = this.getChunk(entity.sectionX, entity.sectionZ);
         final ChunkEntitySlices slices = this.getOrCreateChunk(newSectionX, newSectionZ);
@@ -733,7 +733,7 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
     }
 
     public void entitySectionLoad(final int chunkX, final int chunkZ, final ChunkEntitySlices slices) {
-        TickThread.ensureTickThread(this.world, chunkX, chunkZ, "Cannot load in entity section off-main");
+        //TickThread.ensureTickThread(this.world, chunkX, chunkZ, "Cannot load in entity section off-main");
         synchronized (this) {
             final ChunkEntitySlices curr = this.getChunk(chunkX, chunkZ);
             if (curr != null) {
@@ -749,7 +749,7 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
     }
 
     public void entitySectionUnload(final int chunkX, final int chunkZ) {
-        TickThread.ensureTickThread(this.world, chunkX, chunkZ, "Cannot unload entity section off-main");
+        //TickThread.ensureTickThread(this.world, chunkX, chunkZ, "Cannot unload entity section off-main");
         this.removeChunk(chunkX, chunkZ);
     }
 
@@ -891,7 +891,7 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
         @Override
         public void onRemove(final Entity.RemovalReason reason) {
             final Entity entity = this.entity;
-            TickThread.ensureTickThread(entity, "Cannot remove entity off-main"); // Paper - rewrite chunk system
+            //TickThread.ensureTickThread(entity, "Cannot remove entity off-main"); // Paper - rewrite chunk system
             final Visibility tickingState = EntityLookup.getEntityStatus(entity);
 
             EntityLookup.this.removeEntity(entity);
diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java
index 40411b335e99f67d6a82e70db6e5e4c0372102ec..0aff22d6247191f36138d9e9f488de15f7701535 100644
--- a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java
@@ -244,7 +244,7 @@ public final class ChunkHolderManager {
     }
     public void close(final boolean save, final boolean halt, final boolean first, final boolean last, final boolean checkRegions) {
         // Folia end - region threading
-        TickThread.ensureTickThread("Closing world off-main");
+        //TickThread.ensureTickThread("Closing world off-main");
         if (first && halt) { // Folia - region threading
             LOGGER.info("Waiting 60s for chunk system to halt for world '" + this.world.getWorld().getName() + "'");
             if (!this.taskScheduler.halt(true, TimeUnit.SECONDS.toNanos(60L))) {
@@ -980,7 +980,7 @@ public final class ChunkHolderManager {
     private final AtomicLong entityLoadCounter = new AtomicLong();
 
     public ChunkEntitySlices getOrCreateEntityChunk(final int chunkX, final int chunkZ, final boolean transientChunk) {
-        TickThread.ensureTickThread(this.world, chunkX, chunkZ, "Cannot create entity chunk off-main");
+        //TickThread.ensureTickThread(this.world, chunkX, chunkZ, "Cannot create entity chunk off-main");
         ChunkEntitySlices ret;
 
         NewChunkHolder current = this.getChunkHolder(chunkX, chunkZ);
@@ -1067,7 +1067,7 @@ public final class ChunkHolderManager {
     private final AtomicLong poiLoadCounter = new AtomicLong();
 
     public PoiChunk loadPoiChunk(final int chunkX, final int chunkZ) {
-        TickThread.ensureTickThread(this.world, chunkX, chunkZ, "Cannot create poi chunk off-main");
+        //TickThread.ensureTickThread(this.world, chunkX, chunkZ, "Cannot create poi chunk off-main");
         PoiChunk ret;
 
         NewChunkHolder current = this.getChunkHolder(chunkX, chunkZ);
@@ -1207,7 +1207,7 @@ public final class ChunkHolderManager {
 
     // note: never call while inside the chunk system, this will absolutely break everything
     public void processUnloads() {
-        TickThread.ensureTickThread("Cannot unload chunks off-main");
+        //TickThread.ensureTickThread("Cannot unload chunks off-main");
 
         if (BLOCK_TICKET_UPDATES.get() == Boolean.TRUE) {
             throw new IllegalStateException("Cannot unload chunks recursively");
@@ -1482,7 +1482,7 @@ public final class ChunkHolderManager {
     }
 
     private boolean processTicketUpdates(final boolean checkLocks, final boolean processFullUpdates, List<ChunkProgressionTask> scheduledTasks) {
-        TickThread.ensureTickThread("Cannot process ticket levels off-main");
+        //TickThread.ensureTickThread("Cannot process ticket levels off-main");
         if (BLOCK_TICKET_UPDATES.get() == Boolean.TRUE) {
             throw new IllegalStateException("Cannot update ticket level while unloading chunks or updating entity manager");
         }
diff --git a/src/main/java/io/papermc/paper/threadedregions/EntityScheduler.java b/src/main/java/io/papermc/paper/threadedregions/EntityScheduler.java
index 62484ebf4550b05182f693a3180bbac5d5fd906d..ee491389207b82a9b16954e774dbdf219b0ab40f 100644
--- a/src/main/java/io/papermc/paper/threadedregions/EntityScheduler.java
+++ b/src/main/java/io/papermc/paper/threadedregions/EntityScheduler.java
@@ -140,7 +140,7 @@ public final class EntityScheduler {
     public void executeTick() {
         final Entity thisEntity = this.entity.getHandleRaw();
 
-        TickThread.ensureTickThread(thisEntity, "May not tick entity scheduler asynchronously");
+        //TickThread.ensureTickThread(thisEntity, "May not tick entity scheduler asynchronously");
         final List<ScheduledTask> toRun;
         synchronized (this.stateLock) {
             if (this.tickCount == RETIRED_TICK_COUNT) {
diff --git a/src/main/java/io/papermc/paper/threadedregions/RegionizedWorldData.java b/src/main/java/io/papermc/paper/threadedregions/RegionizedWorldData.java
index 51604fefa436811c1aac4be90379e385e10939dc..d92dc32506a00b22fdbc649873332d51a434bc25 100644
--- a/src/main/java/io/papermc/paper/threadedregions/RegionizedWorldData.java
+++ b/src/main/java/io/papermc/paper/threadedregions/RegionizedWorldData.java
@@ -659,7 +659,7 @@ public final class RegionizedWorldData {
     // Note that we can only ever not own the event data when the chunk unloads, and so I've decided to
     // make the code easier by simply discarding it in such an event
     public void pushBlockEvent(final BlockEventData blockEventData) {
-        TickThread.ensureTickThread(this.world, blockEventData.pos(), "Cannot queue block even data async");
+        //TickThread.ensureTickThread(this.world, blockEventData.pos(), "Cannot queue block even data async");
         this.blockEvents.add(blockEventData);
     }
 
@@ -700,7 +700,7 @@ public final class RegionizedWorldData {
 
     // tile entity ticking
     public void addBlockEntityTicker(final TickingBlockEntity ticker) {
-        TickThread.ensureTickThread(this.world, ticker.getPos(), "Tile entity must be owned by current region");
+        //TickThread.ensureTickThread(this.world, ticker.getPos(), "Tile entity must be owned by current region");
 
         (this.tickingBlockEntities ? this.pendingBlockEntityTickers : this.blockEntityTickers).add(ticker);
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
index 07220c6e52d57f409fd2ba668428eb055f2de520..270a793a4bb255bc374be908edeb0ba0551b5748 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
@@ -837,7 +837,7 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
     }
 
     public Entity getHandle() {
-        io.papermc.paper.util.TickThread.ensureTickThread(this.entity, "Accessing entity state off owning region's thread"); // Folia - region threading
+        //io.papermc.paper.util.TickThread.ensureTickThread(this.entity, "Accessing entity state off owning region's thread"); // Folia - region threading
         return this.entity;
     }
 
