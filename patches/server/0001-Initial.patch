From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Initial Source <auto@mated.null>
Date: Sun, 11 Jun 2023 23:04:35 +0400
Subject: [PATCH] Initial


diff --git a/src/main/java/net/minecraft/advancements/CriterionProgress.java b/src/main/java/net/minecraft/advancements/CriterionProgress.java
new file mode 100644
index 0000000000000000000000000000000000000000..f40d6eaa6ebbd775cd3feb41546423fe4cbf2b22
--- /dev/null
+++ b/src/main/java/net/minecraft/advancements/CriterionProgress.java
@@ -0,0 +1,65 @@
+package net.minecraft.advancements;
+
+import com.google.gson.JsonElement;
+import com.google.gson.JsonNull;
+import com.google.gson.JsonPrimitive;
+import com.google.gson.JsonSyntaxException;
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.Locale;
+import javax.annotation.Nullable;
+import net.minecraft.network.FriendlyByteBuf;
+
+public class CriterionProgress {
+    private static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z", Locale.ROOT);
+    @Nullable
+    private Date obtained;
+
+    public boolean isDone() {
+        return this.obtained != null;
+    }
+
+    public void grant() {
+        this.obtained = new Date();
+    }
+
+    public void revoke() {
+        this.obtained = null;
+    }
+
+    @Nullable
+    public Date getObtained() {
+        return this.obtained;
+    }
+
+    @Override
+    public String toString() {
+        return "CriterionProgress{obtained=" + (this.obtained == null ? "false" : this.obtained) + "}";
+    }
+
+    public void serializeToNetwork(FriendlyByteBuf buf) {
+        buf.writeNullable(this.obtained, FriendlyByteBuf::writeDate);
+    }
+
+    public JsonElement serializeToJson() {
+        return (JsonElement)(this.obtained != null ? new JsonPrimitive(DATE_FORMAT.format(this.obtained)) : JsonNull.INSTANCE);
+    }
+
+    public static CriterionProgress fromNetwork(FriendlyByteBuf buf) {
+        CriterionProgress criterionProgress = new CriterionProgress();
+        criterionProgress.obtained = buf.readNullable(FriendlyByteBuf::readDate);
+        return criterionProgress;
+    }
+
+    public static CriterionProgress fromJson(String datetime) {
+        CriterionProgress criterionProgress = new CriterionProgress();
+
+        try {
+            criterionProgress.obtained = DATE_FORMAT.parse(datetime);
+            return criterionProgress;
+        } catch (ParseException var3) {
+            throw new JsonSyntaxException("Invalid datetime: " + datetime, var3);
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/commands/AdvancementCommands.java b/src/main/java/net/minecraft/server/commands/AdvancementCommands.java
new file mode 100644
index 0000000000000000000000000000000000000000..9852d99dc31f7c7accc6f4fb424d33cc0fd0fa89
--- /dev/null
+++ b/src/main/java/net/minecraft/server/commands/AdvancementCommands.java
@@ -0,0 +1,245 @@
+package net.minecraft.server.commands;
+
+import com.google.common.collect.Lists;
+import com.mojang.brigadier.CommandDispatcher;
+import com.mojang.brigadier.arguments.StringArgumentType;
+import com.mojang.brigadier.suggestion.SuggestionProvider;
+import java.util.Collection;
+import java.util.List;
+import net.minecraft.advancements.Advancement;
+import net.minecraft.advancements.AdvancementProgress;
+import net.minecraft.commands.CommandRuntimeException;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.commands.Commands;
+import net.minecraft.commands.SharedSuggestionProvider;
+import net.minecraft.commands.arguments.EntityArgument;
+import net.minecraft.commands.arguments.ResourceLocationArgument;
+import net.minecraft.network.chat.Component;
+import net.minecraft.server.level.ServerPlayer;
+
+public class AdvancementCommands {
+    private static final SuggestionProvider<CommandSourceStack> SUGGEST_ADVANCEMENTS = (context, builder) -> {
+        Collection<Advancement> collection = context.getSource().getServer().getAdvancements().getAllAdvancements();
+        return SharedSuggestionProvider.suggestResource(collection.stream().map(Advancement::getId), builder);
+    };
+
+    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
+        dispatcher.register(Commands.literal("advancement").requires((source) -> {
+            return source.hasPermission(2);
+        }).then(Commands.literal("grant").then(Commands.argument("targets", EntityArgument.players()).then(Commands.literal("only").then(Commands.argument("advancement", ResourceLocationArgument.id()).suggests(SUGGEST_ADVANCEMENTS).executes((context) -> {
+            return perform(context.getSource(), EntityArgument.getPlayers(context, "targets"), AdvancementCommands.Action.GRANT, getAdvancements(ResourceLocationArgument.getAdvancement(context, "advancement"), AdvancementCommands.Mode.ONLY));
+        }).then(Commands.argument("criterion", StringArgumentType.greedyString()).suggests((context, builder) -> {
+            return SharedSuggestionProvider.suggest(ResourceLocationArgument.getAdvancement(context, "advancement").getCriteria().keySet(), builder);
+        }).executes((context) -> {
+            return performCriterion(context.getSource(), EntityArgument.getPlayers(context, "targets"), AdvancementCommands.Action.GRANT, ResourceLocationArgument.getAdvancement(context, "advancement"), StringArgumentType.getString(context, "criterion"));
+        })))).then(Commands.literal("from").then(Commands.argument("advancement", ResourceLocationArgument.id()).suggests(SUGGEST_ADVANCEMENTS).executes((context) -> {
+            return perform(context.getSource(), EntityArgument.getPlayers(context, "targets"), AdvancementCommands.Action.GRANT, getAdvancements(ResourceLocationArgument.getAdvancement(context, "advancement"), AdvancementCommands.Mode.FROM));
+        }))).then(Commands.literal("until").then(Commands.argument("advancement", ResourceLocationArgument.id()).suggests(SUGGEST_ADVANCEMENTS).executes((context) -> {
+            return perform(context.getSource(), EntityArgument.getPlayers(context, "targets"), AdvancementCommands.Action.GRANT, getAdvancements(ResourceLocationArgument.getAdvancement(context, "advancement"), AdvancementCommands.Mode.UNTIL));
+        }))).then(Commands.literal("through").then(Commands.argument("advancement", ResourceLocationArgument.id()).suggests(SUGGEST_ADVANCEMENTS).executes((context) -> {
+            return perform(context.getSource(), EntityArgument.getPlayers(context, "targets"), AdvancementCommands.Action.GRANT, getAdvancements(ResourceLocationArgument.getAdvancement(context, "advancement"), AdvancementCommands.Mode.THROUGH));
+        }))).then(Commands.literal("everything").executes((context) -> {
+            return perform(context.getSource(), EntityArgument.getPlayers(context, "targets"), AdvancementCommands.Action.GRANT, context.getSource().getServer().getAdvancements().getAllAdvancements());
+        })))).then(Commands.literal("revoke").then(Commands.argument("targets", EntityArgument.players()).then(Commands.literal("only").then(Commands.argument("advancement", ResourceLocationArgument.id()).suggests(SUGGEST_ADVANCEMENTS).executes((context) -> {
+            return perform(context.getSource(), EntityArgument.getPlayers(context, "targets"), AdvancementCommands.Action.REVOKE, getAdvancements(ResourceLocationArgument.getAdvancement(context, "advancement"), AdvancementCommands.Mode.ONLY));
+        }).then(Commands.argument("criterion", StringArgumentType.greedyString()).suggests((context, builder) -> {
+            return SharedSuggestionProvider.suggest(ResourceLocationArgument.getAdvancement(context, "advancement").getCriteria().keySet(), builder);
+        }).executes((context) -> {
+            return performCriterion(context.getSource(), EntityArgument.getPlayers(context, "targets"), AdvancementCommands.Action.REVOKE, ResourceLocationArgument.getAdvancement(context, "advancement"), StringArgumentType.getString(context, "criterion"));
+        })))).then(Commands.literal("from").then(Commands.argument("advancement", ResourceLocationArgument.id()).suggests(SUGGEST_ADVANCEMENTS).executes((context) -> {
+            return perform(context.getSource(), EntityArgument.getPlayers(context, "targets"), AdvancementCommands.Action.REVOKE, getAdvancements(ResourceLocationArgument.getAdvancement(context, "advancement"), AdvancementCommands.Mode.FROM));
+        }))).then(Commands.literal("until").then(Commands.argument("advancement", ResourceLocationArgument.id()).suggests(SUGGEST_ADVANCEMENTS).executes((context) -> {
+            return perform(context.getSource(), EntityArgument.getPlayers(context, "targets"), AdvancementCommands.Action.REVOKE, getAdvancements(ResourceLocationArgument.getAdvancement(context, "advancement"), AdvancementCommands.Mode.UNTIL));
+        }))).then(Commands.literal("through").then(Commands.argument("advancement", ResourceLocationArgument.id()).suggests(SUGGEST_ADVANCEMENTS).executes((context) -> {
+            return perform(context.getSource(), EntityArgument.getPlayers(context, "targets"), AdvancementCommands.Action.REVOKE, getAdvancements(ResourceLocationArgument.getAdvancement(context, "advancement"), AdvancementCommands.Mode.THROUGH));
+        }))).then(Commands.literal("everything").executes((context) -> {
+            return perform(context.getSource(), EntityArgument.getPlayers(context, "targets"), AdvancementCommands.Action.REVOKE, context.getSource().getServer().getAdvancements().getAllAdvancements());
+        })))));
+    }
+
+    private static int perform(CommandSourceStack source, Collection<ServerPlayer> targets, AdvancementCommands.Action operation, Collection<Advancement> selection) {
+        int i = 0;
+
+        for(ServerPlayer serverPlayer : targets) {
+            i += operation.perform(serverPlayer, selection);
+        }
+
+        if (i == 0) {
+            if (selection.size() == 1) {
+                if (targets.size() == 1) {
+                    throw new CommandRuntimeException(Component.translatable(operation.getKey() + ".one.to.one.failure", selection.iterator().next().getChatComponent(), targets.iterator().next().getDisplayName()));
+                } else {
+                    throw new CommandRuntimeException(Component.translatable(operation.getKey() + ".one.to.many.failure", selection.iterator().next().getChatComponent(), targets.size()));
+                }
+            } else if (targets.size() == 1) {
+                throw new CommandRuntimeException(Component.translatable(operation.getKey() + ".many.to.one.failure", selection.size(), targets.iterator().next().getDisplayName()));
+            } else {
+                throw new CommandRuntimeException(Component.translatable(operation.getKey() + ".many.to.many.failure", selection.size(), targets.size()));
+            }
+        } else {
+            if (selection.size() == 1) {
+                if (targets.size() == 1) {
+                    source.sendSuccess(() -> {
+                        return Component.translatable(operation.getKey() + ".one.to.one.success", selection.iterator().next().getChatComponent(), targets.iterator().next().getDisplayName());
+                    }, true);
+                } else {
+                    source.sendSuccess(() -> {
+                        return Component.translatable(operation.getKey() + ".one.to.many.success", selection.iterator().next().getChatComponent(), targets.size());
+                    }, true);
+                }
+            } else if (targets.size() == 1) {
+                source.sendSuccess(() -> {
+                    return Component.translatable(operation.getKey() + ".many.to.one.success", selection.size(), targets.iterator().next().getDisplayName());
+                }, true);
+            } else {
+                source.sendSuccess(() -> {
+                    return Component.translatable(operation.getKey() + ".many.to.many.success", selection.size(), targets.size());
+                }, true);
+            }
+
+            return i;
+        }
+    }
+
+    private static int performCriterion(CommandSourceStack source, Collection<ServerPlayer> targets, AdvancementCommands.Action operation, Advancement advancement, String criterion) {
+        int i = 0;
+        if (!advancement.getCriteria().containsKey(criterion)) {
+            throw new CommandRuntimeException(Component.translatable("commands.advancement.criterionNotFound", advancement.getChatComponent(), criterion));
+        } else {
+            for(ServerPlayer serverPlayer : targets) {
+                if (operation.performCriterion(serverPlayer, advancement, criterion)) {
+                    ++i;
+                }
+            }
+
+            if (i == 0) {
+                if (targets.size() == 1) {
+                    throw new CommandRuntimeException(Component.translatable(operation.getKey() + ".criterion.to.one.failure", criterion, advancement.getChatComponent(), targets.iterator().next().getDisplayName()));
+                } else {
+                    throw new CommandRuntimeException(Component.translatable(operation.getKey() + ".criterion.to.many.failure", criterion, advancement.getChatComponent(), targets.size()));
+                }
+            } else {
+                if (targets.size() == 1) {
+                    source.sendSuccess(() -> {
+                        return Component.translatable(operation.getKey() + ".criterion.to.one.success", criterion, advancement.getChatComponent(), targets.iterator().next().getDisplayName());
+                    }, true);
+                } else {
+                    source.sendSuccess(() -> {
+                        return Component.translatable(operation.getKey() + ".criterion.to.many.success", criterion, advancement.getChatComponent(), targets.size());
+                    }, true);
+                }
+
+                return i;
+            }
+        }
+    }
+
+    private static List<Advancement> getAdvancements(Advancement advancement, AdvancementCommands.Mode selection) {
+        List<Advancement> list = Lists.newArrayList();
+        if (selection.parents) {
+            for(Advancement advancement2 = advancement.getParent(); advancement2 != null; advancement2 = advancement2.getParent()) {
+                list.add(advancement2);
+            }
+        }
+
+        list.add(advancement);
+        if (selection.children) {
+            addChildren(advancement, list);
+        }
+
+        return list;
+    }
+
+    private static void addChildren(Advancement parent, List<Advancement> childList) {
+        for(Advancement advancement : parent.getChildren()) {
+            childList.add(advancement);
+            addChildren(advancement, childList);
+        }
+
+    }
+
+    static enum Action {
+        GRANT("grant") {
+            @Override
+            protected boolean perform(ServerPlayer player, Advancement advancement) {
+                AdvancementProgress advancementProgress = player.getAdvancements().getOrStartProgress(advancement);
+                if (advancementProgress.isDone()) {
+                    return false;
+                } else {
+                    for(String string : advancementProgress.getRemainingCriteria()) {
+                        player.getAdvancements().award(advancement, string);
+                    }
+
+                    return true;
+                }
+            }
+
+            @Override
+            protected boolean performCriterion(ServerPlayer player, Advancement advancement, String criterion) {
+                return player.getAdvancements().award(advancement, criterion);
+            }
+        },
+        REVOKE("revoke") {
+            @Override
+            protected boolean perform(ServerPlayer player, Advancement advancement) {
+                AdvancementProgress advancementProgress = player.getAdvancements().getOrStartProgress(advancement);
+                if (!advancementProgress.hasProgress()) {
+                    return false;
+                } else {
+                    for(String string : advancementProgress.getCompletedCriteria()) {
+                        player.getAdvancements().revoke(advancement, string);
+                    }
+
+                    return true;
+                }
+            }
+
+            @Override
+            protected boolean performCriterion(ServerPlayer player, Advancement advancement, String criterion) {
+                return player.getAdvancements().revoke(advancement, criterion);
+            }
+        };
+
+        private final String key;
+
+        Action(String name) {
+            this.key = "commands.advancement." + name;
+        }
+
+        public int perform(ServerPlayer player, Iterable<Advancement> advancements) {
+            int i = 0;
+
+            for(Advancement advancement : advancements) {
+                if (this.perform(player, advancement)) {
+                    ++i;
+                }
+            }
+
+            return i;
+        }
+
+        protected abstract boolean perform(ServerPlayer player, Advancement advancement);
+
+        protected abstract boolean performCriterion(ServerPlayer player, Advancement advancement, String criterion);
+
+        protected String getKey() {
+            return this.key;
+        }
+    }
+
+    static enum Mode {
+        ONLY(false, false),
+        THROUGH(true, true),
+        FROM(false, true),
+        UNTIL(true, false),
+        EVERYTHING(true, true);
+
+        final boolean parents;
+        final boolean children;
+
+        private Mode(boolean before, boolean after) {
+            this.parents = before;
+            this.children = after;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/commands/AttributeCommand.java b/src/main/java/net/minecraft/server/commands/AttributeCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..506c5a8369ec0b2af3605e5bdfce8b000cf56ec4
--- /dev/null
+++ b/src/main/java/net/minecraft/server/commands/AttributeCommand.java
@@ -0,0 +1,164 @@
+package net.minecraft.server.commands;
+
+import com.mojang.brigadier.CommandDispatcher;
+import com.mojang.brigadier.arguments.DoubleArgumentType;
+import com.mojang.brigadier.arguments.StringArgumentType;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import com.mojang.brigadier.exceptions.Dynamic2CommandExceptionType;
+import com.mojang.brigadier.exceptions.Dynamic3CommandExceptionType;
+import com.mojang.brigadier.exceptions.DynamicCommandExceptionType;
+import java.util.UUID;
+import net.minecraft.commands.CommandBuildContext;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.commands.Commands;
+import net.minecraft.commands.arguments.EntityArgument;
+import net.minecraft.commands.arguments.ResourceArgument;
+import net.minecraft.commands.arguments.UuidArgument;
+import net.minecraft.core.Holder;
+import net.minecraft.core.registries.Registries;
+import net.minecraft.network.chat.Component;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.entity.ai.attributes.Attribute;
+import net.minecraft.world.entity.ai.attributes.AttributeInstance;
+import net.minecraft.world.entity.ai.attributes.AttributeMap;
+import net.minecraft.world.entity.ai.attributes.AttributeModifier;
+
+public class AttributeCommand {
+    private static final DynamicCommandExceptionType ERROR_NOT_LIVING_ENTITY = new DynamicCommandExceptionType((name) -> {
+        return Component.translatable("commands.attribute.failed.entity", name);
+    });
+    private static final Dynamic2CommandExceptionType ERROR_NO_SUCH_ATTRIBUTE = new Dynamic2CommandExceptionType((entityName, attributeName) -> {
+        return Component.translatable("commands.attribute.failed.no_attribute", entityName, attributeName);
+    });
+    private static final Dynamic3CommandExceptionType ERROR_NO_SUCH_MODIFIER = new Dynamic3CommandExceptionType((entityName, attributeName, uuid) -> {
+        return Component.translatable("commands.attribute.failed.no_modifier", attributeName, entityName, uuid);
+    });
+    private static final Dynamic3CommandExceptionType ERROR_MODIFIER_ALREADY_PRESENT = new Dynamic3CommandExceptionType((entityName, attributeName, uuid) -> {
+        return Component.translatable("commands.attribute.failed.modifier_already_present", uuid, attributeName, entityName);
+    });
+
+    public static void register(CommandDispatcher<CommandSourceStack> dispatcher, CommandBuildContext registryAccess) {
+        dispatcher.register(Commands.literal("attribute").requires((source) -> {
+            return source.hasPermission(2);
+        }).then(Commands.argument("target", EntityArgument.entity()).then(Commands.argument("attribute", ResourceArgument.resource(registryAccess, Registries.ATTRIBUTE)).then(Commands.literal("get").executes((context) -> {
+            return getAttributeValue(context.getSource(), EntityArgument.getEntity(context, "target"), ResourceArgument.getAttribute(context, "attribute"), 1.0D);
+        }).then(Commands.argument("scale", DoubleArgumentType.doubleArg()).executes((context) -> {
+            return getAttributeValue(context.getSource(), EntityArgument.getEntity(context, "target"), ResourceArgument.getAttribute(context, "attribute"), DoubleArgumentType.getDouble(context, "scale"));
+        }))).then(Commands.literal("base").then(Commands.literal("set").then(Commands.argument("value", DoubleArgumentType.doubleArg()).executes((context) -> {
+            return setAttributeBase(context.getSource(), EntityArgument.getEntity(context, "target"), ResourceArgument.getAttribute(context, "attribute"), DoubleArgumentType.getDouble(context, "value"));
+        }))).then(Commands.literal("get").executes((context) -> {
+            return getAttributeBase(context.getSource(), EntityArgument.getEntity(context, "target"), ResourceArgument.getAttribute(context, "attribute"), 1.0D);
+        }).then(Commands.argument("scale", DoubleArgumentType.doubleArg()).executes((context) -> {
+            return getAttributeBase(context.getSource(), EntityArgument.getEntity(context, "target"), ResourceArgument.getAttribute(context, "attribute"), DoubleArgumentType.getDouble(context, "scale"));
+        })))).then(Commands.literal("modifier").then(Commands.literal("add").then(Commands.argument("uuid", UuidArgument.uuid()).then(Commands.argument("name", StringArgumentType.string()).then(Commands.argument("value", DoubleArgumentType.doubleArg()).then(Commands.literal("add").executes((context) -> {
+            return addModifier(context.getSource(), EntityArgument.getEntity(context, "target"), ResourceArgument.getAttribute(context, "attribute"), UuidArgument.getUuid(context, "uuid"), StringArgumentType.getString(context, "name"), DoubleArgumentType.getDouble(context, "value"), AttributeModifier.Operation.ADDITION);
+        })).then(Commands.literal("multiply").executes((context) -> {
+            return addModifier(context.getSource(), EntityArgument.getEntity(context, "target"), ResourceArgument.getAttribute(context, "attribute"), UuidArgument.getUuid(context, "uuid"), StringArgumentType.getString(context, "name"), DoubleArgumentType.getDouble(context, "value"), AttributeModifier.Operation.MULTIPLY_TOTAL);
+        })).then(Commands.literal("multiply_base").executes((context) -> {
+            return addModifier(context.getSource(), EntityArgument.getEntity(context, "target"), ResourceArgument.getAttribute(context, "attribute"), UuidArgument.getUuid(context, "uuid"), StringArgumentType.getString(context, "name"), DoubleArgumentType.getDouble(context, "value"), AttributeModifier.Operation.MULTIPLY_BASE);
+        })))))).then(Commands.literal("remove").then(Commands.argument("uuid", UuidArgument.uuid()).executes((context) -> {
+            return removeModifier(context.getSource(), EntityArgument.getEntity(context, "target"), ResourceArgument.getAttribute(context, "attribute"), UuidArgument.getUuid(context, "uuid"));
+        }))).then(Commands.literal("value").then(Commands.literal("get").then(Commands.argument("uuid", UuidArgument.uuid()).executes((context) -> {
+            return getAttributeModifier(context.getSource(), EntityArgument.getEntity(context, "target"), ResourceArgument.getAttribute(context, "attribute"), UuidArgument.getUuid(context, "uuid"), 1.0D);
+        }).then(Commands.argument("scale", DoubleArgumentType.doubleArg()).executes((context) -> {
+            return getAttributeModifier(context.getSource(), EntityArgument.getEntity(context, "target"), ResourceArgument.getAttribute(context, "attribute"), UuidArgument.getUuid(context, "uuid"), DoubleArgumentType.getDouble(context, "scale"));
+        })))))))));
+    }
+
+    private static AttributeInstance getAttributeInstance(Entity entity, Holder<Attribute> attribute) throws CommandSyntaxException {
+        AttributeInstance attributeInstance = getLivingEntity(entity).getAttributes().getInstance(attribute);
+        if (attributeInstance == null) {
+            throw ERROR_NO_SUCH_ATTRIBUTE.create(entity.getName(), getAttributeDescription(attribute));
+        } else {
+            return attributeInstance;
+        }
+    }
+
+    private static LivingEntity getLivingEntity(Entity entity) throws CommandSyntaxException {
+        if (!(entity instanceof LivingEntity)) {
+            throw ERROR_NOT_LIVING_ENTITY.create(entity.getName());
+        } else {
+            return (LivingEntity)entity;
+        }
+    }
+
+    private static LivingEntity getEntityWithAttribute(Entity entity, Holder<Attribute> attribute) throws CommandSyntaxException {
+        LivingEntity livingEntity = getLivingEntity(entity);
+        if (!livingEntity.getAttributes().hasAttribute(attribute)) {
+            throw ERROR_NO_SUCH_ATTRIBUTE.create(entity.getName(), getAttributeDescription(attribute));
+        } else {
+            return livingEntity;
+        }
+    }
+
+    private static int getAttributeValue(CommandSourceStack source, Entity target, Holder<Attribute> attribute, double multiplier) throws CommandSyntaxException {
+        LivingEntity livingEntity = getEntityWithAttribute(target, attribute);
+        double d = livingEntity.getAttributeValue(attribute);
+        source.sendSuccess(() -> {
+            return Component.translatable("commands.attribute.value.get.success", getAttributeDescription(attribute), target.getName(), d);
+        }, false);
+        return (int)(d * multiplier);
+    }
+
+    private static int getAttributeBase(CommandSourceStack source, Entity target, Holder<Attribute> attribute, double multiplier) throws CommandSyntaxException {
+        LivingEntity livingEntity = getEntityWithAttribute(target, attribute);
+        double d = livingEntity.getAttributeBaseValue(attribute);
+        source.sendSuccess(() -> {
+            return Component.translatable("commands.attribute.base_value.get.success", getAttributeDescription(attribute), target.getName(), d);
+        }, false);
+        return (int)(d * multiplier);
+    }
+
+    private static int getAttributeModifier(CommandSourceStack source, Entity target, Holder<Attribute> attribute, UUID uuid, double multiplier) throws CommandSyntaxException {
+        LivingEntity livingEntity = getEntityWithAttribute(target, attribute);
+        AttributeMap attributeMap = livingEntity.getAttributes();
+        if (!attributeMap.hasModifier(attribute, uuid)) {
+            throw ERROR_NO_SUCH_MODIFIER.create(target.getName(), getAttributeDescription(attribute), uuid);
+        } else {
+            double d = attributeMap.getModifierValue(attribute, uuid);
+            source.sendSuccess(() -> {
+                return Component.translatable("commands.attribute.modifier.value.get.success", uuid, getAttributeDescription(attribute), target.getName(), d);
+            }, false);
+            return (int)(d * multiplier);
+        }
+    }
+
+    private static int setAttributeBase(CommandSourceStack source, Entity target, Holder<Attribute> attribute, double value) throws CommandSyntaxException {
+        getAttributeInstance(target, attribute).setBaseValue(value);
+        source.sendSuccess(() -> {
+            return Component.translatable("commands.attribute.base_value.set.success", getAttributeDescription(attribute), target.getName(), value);
+        }, false);
+        return 1;
+    }
+
+    private static int addModifier(CommandSourceStack source, Entity target, Holder<Attribute> attribute, UUID uuid, String name, double value, AttributeModifier.Operation operation) throws CommandSyntaxException {
+        AttributeInstance attributeInstance = getAttributeInstance(target, attribute);
+        AttributeModifier attributeModifier = new AttributeModifier(uuid, name, value, operation);
+        if (attributeInstance.hasModifier(attributeModifier)) {
+            throw ERROR_MODIFIER_ALREADY_PRESENT.create(target.getName(), getAttributeDescription(attribute), uuid);
+        } else {
+            attributeInstance.addPermanentModifier(attributeModifier);
+            source.sendSuccess(() -> {
+                return Component.translatable("commands.attribute.modifier.add.success", uuid, getAttributeDescription(attribute), target.getName());
+            }, false);
+            return 1;
+        }
+    }
+
+    private static int removeModifier(CommandSourceStack source, Entity target, Holder<Attribute> attribute, UUID uuid) throws CommandSyntaxException {
+        AttributeInstance attributeInstance = getAttributeInstance(target, attribute);
+        if (attributeInstance.removePermanentModifier(uuid)) {
+            source.sendSuccess(() -> {
+                return Component.translatable("commands.attribute.modifier.remove.success", uuid, getAttributeDescription(attribute), target.getName());
+            }, false);
+            return 1;
+        } else {
+            throw ERROR_NO_SUCH_MODIFIER.create(target.getName(), getAttributeDescription(attribute), uuid);
+        }
+    }
+
+    private static Component getAttributeDescription(Holder<Attribute> attribute) {
+        return Component.translatable(attribute.value().getDescriptionId());
+    }
+}
diff --git a/src/main/java/net/minecraft/server/commands/ClearInventoryCommands.java b/src/main/java/net/minecraft/server/commands/ClearInventoryCommands.java
new file mode 100644
index 0000000000000000000000000000000000000000..90c061eaf40ed756dcd56bb877a617a219ea90e1
--- /dev/null
+++ b/src/main/java/net/minecraft/server/commands/ClearInventoryCommands.java
@@ -0,0 +1,85 @@
+package net.minecraft.server.commands;
+
+import com.mojang.brigadier.CommandDispatcher;
+import com.mojang.brigadier.arguments.IntegerArgumentType;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import com.mojang.brigadier.exceptions.DynamicCommandExceptionType;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.function.Predicate;
+import net.minecraft.commands.CommandBuildContext;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.commands.Commands;
+import net.minecraft.commands.arguments.EntityArgument;
+import net.minecraft.commands.arguments.item.ItemPredicateArgument;
+import net.minecraft.network.chat.Component;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.item.ItemStack;
+
+public class ClearInventoryCommands {
+    private static final DynamicCommandExceptionType ERROR_SINGLE = new DynamicCommandExceptionType((playerName) -> {
+        return Component.translatable("clear.failed.single", playerName);
+    });
+    private static final DynamicCommandExceptionType ERROR_MULTIPLE = new DynamicCommandExceptionType((playerCount) -> {
+        return Component.translatable("clear.failed.multiple", playerCount);
+    });
+
+    public static void register(CommandDispatcher<CommandSourceStack> dispatcher, CommandBuildContext commandRegistryAccess) {
+        dispatcher.register(Commands.literal("clear").requires((source) -> {
+            return source.hasPermission(2);
+        }).executes((context) -> {
+            return clearInventory(context.getSource(), Collections.singleton(context.getSource().getPlayerOrException()), (stack) -> {
+                return true;
+            }, -1);
+        }).then(Commands.argument("targets", EntityArgument.players()).executes((context) -> {
+            return clearInventory(context.getSource(), EntityArgument.getPlayers(context, "targets"), (stack) -> {
+                return true;
+            }, -1);
+        }).then(Commands.argument("item", ItemPredicateArgument.itemPredicate(commandRegistryAccess)).executes((context) -> {
+            return clearInventory(context.getSource(), EntityArgument.getPlayers(context, "targets"), ItemPredicateArgument.getItemPredicate(context, "item"), -1);
+        }).then(Commands.argument("maxCount", IntegerArgumentType.integer(0)).executes((context) -> {
+            return clearInventory(context.getSource(), EntityArgument.getPlayers(context, "targets"), ItemPredicateArgument.getItemPredicate(context, "item"), IntegerArgumentType.getInteger(context, "maxCount"));
+        })))));
+    }
+
+    private static int clearInventory(CommandSourceStack source, Collection<ServerPlayer> targets, Predicate<ItemStack> item, int maxCount) throws CommandSyntaxException {
+        int i = 0;
+
+        for(ServerPlayer serverPlayer : targets) {
+            i += serverPlayer.getInventory().clearOrCountMatchingItems(item, maxCount, serverPlayer.inventoryMenu.getCraftSlots());
+            serverPlayer.containerMenu.broadcastChanges();
+            serverPlayer.inventoryMenu.slotsChanged(serverPlayer.getInventory());
+        }
+
+        if (i == 0) {
+            if (targets.size() == 1) {
+                throw ERROR_SINGLE.create(targets.iterator().next().getName());
+            } else {
+                throw ERROR_MULTIPLE.create(targets.size());
+            }
+        } else {
+            int j = i;
+            if (maxCount == 0) {
+                if (targets.size() == 1) {
+                    source.sendSuccess(() -> {
+                        return Component.translatable("commands.clear.test.single", j, targets.iterator().next().getDisplayName());
+                    }, true);
+                } else {
+                    source.sendSuccess(() -> {
+                        return Component.translatable("commands.clear.test.multiple", j, targets.size());
+                    }, true);
+                }
+            } else if (targets.size() == 1) {
+                source.sendSuccess(() -> {
+                    return Component.translatable("commands.clear.success.single", j, targets.iterator().next().getDisplayName());
+                }, true);
+            } else {
+                source.sendSuccess(() -> {
+                    return Component.translatable("commands.clear.success.multiple", j, targets.size());
+                }, true);
+            }
+
+            return i;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/commands/DamageCommand.java b/src/main/java/net/minecraft/server/commands/DamageCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..b8250748606d0356da0e15d432784fb3ae59438a
--- /dev/null
+++ b/src/main/java/net/minecraft/server/commands/DamageCommand.java
@@ -0,0 +1,47 @@
+package net.minecraft.server.commands;
+
+import com.mojang.brigadier.CommandDispatcher;
+import com.mojang.brigadier.arguments.FloatArgumentType;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
+import net.minecraft.commands.CommandBuildContext;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.commands.Commands;
+import net.minecraft.commands.arguments.EntityArgument;
+import net.minecraft.commands.arguments.ResourceArgument;
+import net.minecraft.commands.arguments.coordinates.Vec3Argument;
+import net.minecraft.core.registries.Registries;
+import net.minecraft.network.chat.Component;
+import net.minecraft.world.damagesource.DamageSource;
+import net.minecraft.world.entity.Entity;
+
+public class DamageCommand {
+    private static final SimpleCommandExceptionType ERROR_INVULNERABLE = new SimpleCommandExceptionType(Component.translatable("commands.damage.invulnerable"));
+
+    public static void register(CommandDispatcher<CommandSourceStack> dispatcher, CommandBuildContext registryAccess) {
+        dispatcher.register(Commands.literal("damage").requires((source) -> {
+            return source.hasPermission(2);
+        }).then(Commands.argument("target", EntityArgument.entity()).then(Commands.argument("amount", FloatArgumentType.floatArg(0.0F)).executes((context) -> {
+            return damage(context.getSource(), EntityArgument.getEntity(context, "target"), FloatArgumentType.getFloat(context, "amount"), context.getSource().getLevel().damageSources().generic());
+        }).then(Commands.argument("damageType", ResourceArgument.resource(registryAccess, Registries.DAMAGE_TYPE)).executes((context) -> {
+            return damage(context.getSource(), EntityArgument.getEntity(context, "target"), FloatArgumentType.getFloat(context, "amount"), new DamageSource(ResourceArgument.getResource(context, "damageType", Registries.DAMAGE_TYPE)));
+        }).then(Commands.literal("at").then(Commands.argument("location", Vec3Argument.vec3()).executes((context) -> {
+            return damage(context.getSource(), EntityArgument.getEntity(context, "target"), FloatArgumentType.getFloat(context, "amount"), new DamageSource(ResourceArgument.getResource(context, "damageType", Registries.DAMAGE_TYPE), Vec3Argument.getVec3(context, "location")));
+        }))).then(Commands.literal("by").then(Commands.argument("entity", EntityArgument.entity()).executes((context) -> {
+            return damage(context.getSource(), EntityArgument.getEntity(context, "target"), FloatArgumentType.getFloat(context, "amount"), new DamageSource(ResourceArgument.getResource(context, "damageType", Registries.DAMAGE_TYPE), EntityArgument.getEntity(context, "entity")));
+        }).then(Commands.literal("from").then(Commands.argument("cause", EntityArgument.entity()).executes((context) -> {
+            return damage(context.getSource(), EntityArgument.getEntity(context, "target"), FloatArgumentType.getFloat(context, "amount"), new DamageSource(ResourceArgument.getResource(context, "damageType", Registries.DAMAGE_TYPE), EntityArgument.getEntity(context, "entity"), EntityArgument.getEntity(context, "cause")));
+        })))))))));
+    }
+
+    private static int damage(CommandSourceStack source, Entity target, float amount, DamageSource damageSource) throws CommandSyntaxException {
+        if (target.hurt(damageSource, amount)) {
+            source.sendSuccess(() -> {
+                return Component.translatable("commands.damage.success", amount, target.getDisplayName());
+            }, true);
+            return 1;
+        } else {
+            throw ERROR_INVULNERABLE.create();
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/commands/EnchantCommand.java b/src/main/java/net/minecraft/server/commands/EnchantCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..664cbce2e06fcb95d3d3d6c5302fc9119f938925
--- /dev/null
+++ b/src/main/java/net/minecraft/server/commands/EnchantCommand.java
@@ -0,0 +1,92 @@
+package net.minecraft.server.commands;
+
+import com.mojang.brigadier.CommandDispatcher;
+import com.mojang.brigadier.arguments.IntegerArgumentType;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import com.mojang.brigadier.exceptions.Dynamic2CommandExceptionType;
+import com.mojang.brigadier.exceptions.DynamicCommandExceptionType;
+import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
+import java.util.Collection;
+import net.minecraft.commands.CommandBuildContext;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.commands.Commands;
+import net.minecraft.commands.arguments.EntityArgument;
+import net.minecraft.commands.arguments.ResourceArgument;
+import net.minecraft.core.Holder;
+import net.minecraft.core.registries.Registries;
+import net.minecraft.network.chat.Component;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.enchantment.Enchantment;
+import net.minecraft.world.item.enchantment.EnchantmentHelper;
+
+public class EnchantCommand {
+    private static final DynamicCommandExceptionType ERROR_NOT_LIVING_ENTITY = new DynamicCommandExceptionType((entityName) -> {
+        return Component.translatable("commands.enchant.failed.entity", entityName);
+    });
+    private static final DynamicCommandExceptionType ERROR_NO_ITEM = new DynamicCommandExceptionType((entityName) -> {
+        return Component.translatable("commands.enchant.failed.itemless", entityName);
+    });
+    private static final DynamicCommandExceptionType ERROR_INCOMPATIBLE = new DynamicCommandExceptionType((itemName) -> {
+        return Component.translatable("commands.enchant.failed.incompatible", itemName);
+    });
+    private static final Dynamic2CommandExceptionType ERROR_LEVEL_TOO_HIGH = new Dynamic2CommandExceptionType((level, maxLevel) -> {
+        return Component.translatable("commands.enchant.failed.level", level, maxLevel);
+    });
+    private static final SimpleCommandExceptionType ERROR_NOTHING_HAPPENED = new SimpleCommandExceptionType(Component.translatable("commands.enchant.failed"));
+
+    public static void register(CommandDispatcher<CommandSourceStack> dispatcher, CommandBuildContext registryAccess) {
+        dispatcher.register(Commands.literal("enchant").requires((source) -> {
+            return source.hasPermission(2);
+        }).then(Commands.argument("targets", EntityArgument.entities()).then(Commands.argument("enchantment", ResourceArgument.resource(registryAccess, Registries.ENCHANTMENT)).executes((context) -> {
+            return enchant(context.getSource(), EntityArgument.getEntities(context, "targets"), ResourceArgument.getEnchantment(context, "enchantment"), 1);
+        }).then(Commands.argument("level", IntegerArgumentType.integer(0)).executes((context) -> {
+            return enchant(context.getSource(), EntityArgument.getEntities(context, "targets"), ResourceArgument.getEnchantment(context, "enchantment"), IntegerArgumentType.getInteger(context, "level"));
+        })))));
+    }
+
+    private static int enchant(CommandSourceStack source, Collection<? extends Entity> targets, Holder<Enchantment> enchantment, int level) throws CommandSyntaxException {
+        Enchantment enchantment2 = enchantment.value();
+        if (level > enchantment2.getMaxLevel()) {
+            throw ERROR_LEVEL_TOO_HIGH.create(level, enchantment2.getMaxLevel());
+        } else {
+            int i = 0;
+
+            for(Entity entity : targets) {
+                if (entity instanceof LivingEntity) {
+                    LivingEntity livingEntity = (LivingEntity)entity;
+                    ItemStack itemStack = livingEntity.getMainHandItem();
+                    if (!itemStack.isEmpty()) {
+                        if (enchantment2.canEnchant(itemStack) && EnchantmentHelper.isEnchantmentCompatible(EnchantmentHelper.getEnchantments(itemStack).keySet(), enchantment2)) {
+                            itemStack.enchant(enchantment2, level);
+                            ++i;
+                        } else if (targets.size() == 1) {
+                            throw ERROR_INCOMPATIBLE.create(itemStack.getItem().getName(itemStack).getString());
+                        }
+                    } else if (targets.size() == 1) {
+                        throw ERROR_NO_ITEM.create(livingEntity.getName().getString());
+                    }
+                } else if (targets.size() == 1) {
+                    throw ERROR_NOT_LIVING_ENTITY.create(entity.getName().getString());
+                }
+            }
+
+            if (i == 0) {
+                throw ERROR_NOTHING_HAPPENED.create();
+            } else {
+                if (targets.size() == 1) {
+                    source.sendSuccess(() -> {
+                        return Component.translatable("commands.enchant.success.single", enchantment2.getFullname(level), targets.iterator().next().getDisplayName());
+                    }, true);
+                } else {
+                    source.sendSuccess(() -> {
+                        return Component.translatable("commands.enchant.success.multiple", enchantment2.getFullname(level), targets.size());
+                    }, true);
+                }
+
+                return i;
+            }
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/commands/ExperienceCommand.java b/src/main/java/net/minecraft/server/commands/ExperienceCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..24dfe8e9697331f0d7e67e90b9ca537d7ead575e
--- /dev/null
+++ b/src/main/java/net/minecraft/server/commands/ExperienceCommand.java
@@ -0,0 +1,130 @@
+package net.minecraft.server.commands;
+
+import com.mojang.brigadier.CommandDispatcher;
+import com.mojang.brigadier.arguments.IntegerArgumentType;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
+import com.mojang.brigadier.tree.LiteralCommandNode;
+import java.util.Collection;
+import java.util.function.BiConsumer;
+import java.util.function.BiPredicate;
+import java.util.function.ToIntFunction;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.commands.Commands;
+import net.minecraft.commands.arguments.EntityArgument;
+import net.minecraft.network.chat.Component;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.util.Mth;
+import net.minecraft.world.entity.player.Player;
+
+public class ExperienceCommand {
+    private static final SimpleCommandExceptionType ERROR_SET_POINTS_INVALID = new SimpleCommandExceptionType(Component.translatable("commands.experience.set.points.invalid"));
+
+    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
+        LiteralCommandNode<CommandSourceStack> literalCommandNode = dispatcher.register(Commands.literal("experience").requires((source) -> {
+            return source.hasPermission(2);
+        }).then(Commands.literal("add").then(Commands.argument("targets", EntityArgument.players()).then(Commands.argument("amount", IntegerArgumentType.integer()).executes((context) -> {
+            return addExperience(context.getSource(), EntityArgument.getPlayers(context, "targets"), IntegerArgumentType.getInteger(context, "amount"), ExperienceCommand.Type.POINTS);
+        }).then(Commands.literal("points").executes((context) -> {
+            return addExperience(context.getSource(), EntityArgument.getPlayers(context, "targets"), IntegerArgumentType.getInteger(context, "amount"), ExperienceCommand.Type.POINTS);
+        })).then(Commands.literal("levels").executes((context) -> {
+            return addExperience(context.getSource(), EntityArgument.getPlayers(context, "targets"), IntegerArgumentType.getInteger(context, "amount"), ExperienceCommand.Type.LEVELS);
+        }))))).then(Commands.literal("set").then(Commands.argument("targets", EntityArgument.players()).then(Commands.argument("amount", IntegerArgumentType.integer(0)).executes((context) -> {
+            return setExperience(context.getSource(), EntityArgument.getPlayers(context, "targets"), IntegerArgumentType.getInteger(context, "amount"), ExperienceCommand.Type.POINTS);
+        }).then(Commands.literal("points").executes((context) -> {
+            return setExperience(context.getSource(), EntityArgument.getPlayers(context, "targets"), IntegerArgumentType.getInteger(context, "amount"), ExperienceCommand.Type.POINTS);
+        })).then(Commands.literal("levels").executes((context) -> {
+            return setExperience(context.getSource(), EntityArgument.getPlayers(context, "targets"), IntegerArgumentType.getInteger(context, "amount"), ExperienceCommand.Type.LEVELS);
+        }))))).then(Commands.literal("query").then(Commands.argument("targets", EntityArgument.player()).then(Commands.literal("points").executes((context) -> {
+            return queryExperience(context.getSource(), EntityArgument.getPlayer(context, "targets"), ExperienceCommand.Type.POINTS);
+        })).then(Commands.literal("levels").executes((context) -> {
+            return queryExperience(context.getSource(), EntityArgument.getPlayer(context, "targets"), ExperienceCommand.Type.LEVELS);
+        })))));
+        dispatcher.register(Commands.literal("xp").requires((source) -> {
+            return source.hasPermission(2);
+        }).redirect(literalCommandNode));
+    }
+
+    private static int queryExperience(CommandSourceStack source, ServerPlayer player, ExperienceCommand.Type component) {
+        int i = component.query.applyAsInt(player);
+        source.sendSuccess(() -> {
+            return Component.translatable("commands.experience.query." + component.name, player.getDisplayName(), i);
+        }, false);
+        return i;
+    }
+
+    private static int addExperience(CommandSourceStack source, Collection<? extends ServerPlayer> targets, int amount, ExperienceCommand.Type component) {
+        for(ServerPlayer serverPlayer : targets) {
+            component.add.accept(serverPlayer, amount);
+        }
+
+        if (targets.size() == 1) {
+            source.sendSuccess(() -> {
+                return Component.translatable("commands.experience.add." + component.name + ".success.single", amount, targets.iterator().next().getDisplayName());
+            }, true);
+        } else {
+            source.sendSuccess(() -> {
+                return Component.translatable("commands.experience.add." + component.name + ".success.multiple", amount, targets.size());
+            }, true);
+        }
+
+        return targets.size();
+    }
+
+    private static int setExperience(CommandSourceStack source, Collection<? extends ServerPlayer> targets, int amount, ExperienceCommand.Type component) throws CommandSyntaxException {
+        int i = 0;
+
+        for(ServerPlayer serverPlayer : targets) {
+            if (component.set.test(serverPlayer, amount)) {
+                ++i;
+            }
+        }
+
+        if (i == 0) {
+            throw ERROR_SET_POINTS_INVALID.create();
+        } else {
+            if (targets.size() == 1) {
+                source.sendSuccess(() -> {
+                    return Component.translatable("commands.experience.set." + component.name + ".success.single", amount, targets.iterator().next().getDisplayName());
+                }, true);
+            } else {
+                source.sendSuccess(() -> {
+                    return Component.translatable("commands.experience.set." + component.name + ".success.multiple", amount, targets.size());
+                }, true);
+            }
+
+            return targets.size();
+        }
+    }
+
+    static enum Type {
+        POINTS("points", Player::giveExperiencePoints, (player, xp) -> {
+            if (xp >= player.getXpNeededForNextLevel()) {
+                return false;
+            } else {
+                player.setExperiencePoints(xp);
+                return true;
+            }
+        }, (player) -> {
+            return Mth.floor(player.experienceProgress * (float)player.getXpNeededForNextLevel());
+        }),
+        LEVELS("levels", ServerPlayer::giveExperienceLevels, (player, level) -> {
+            player.setExperienceLevels(level);
+            return true;
+        }, (player) -> {
+            return player.experienceLevel;
+        });
+
+        public final BiConsumer<ServerPlayer, Integer> add;
+        public final BiPredicate<ServerPlayer, Integer> set;
+        public final String name;
+        final ToIntFunction<ServerPlayer> query;
+
+        private Type(String name, BiConsumer<ServerPlayer, Integer> adder, BiPredicate<ServerPlayer, Integer> setter, ToIntFunction<ServerPlayer> getter) {
+            this.add = adder;
+            this.name = name;
+            this.set = setter;
+            this.query = getter;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/commands/FillBiomeCommand.java b/src/main/java/net/minecraft/server/commands/FillBiomeCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..618f524a7bba8e5c75445872538c5fd1ceff20e4
--- /dev/null
+++ b/src/main/java/net/minecraft/server/commands/FillBiomeCommand.java
@@ -0,0 +1,109 @@
+package net.minecraft.server.commands;
+
+import com.mojang.brigadier.CommandDispatcher;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import com.mojang.brigadier.exceptions.Dynamic2CommandExceptionType;
+import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.function.Predicate;
+import net.minecraft.commands.CommandBuildContext;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.commands.Commands;
+import net.minecraft.commands.arguments.ResourceArgument;
+import net.minecraft.commands.arguments.ResourceOrTagArgument;
+import net.minecraft.commands.arguments.coordinates.BlockPosArgument;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Holder;
+import net.minecraft.core.QuartPos;
+import net.minecraft.core.SectionPos;
+import net.minecraft.core.registries.Registries;
+import net.minecraft.network.chat.Component;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.GameRules;
+import net.minecraft.world.level.biome.Biome;
+import net.minecraft.world.level.biome.BiomeResolver;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.ChunkStatus;
+import net.minecraft.world.level.levelgen.structure.BoundingBox;
+import org.apache.commons.lang3.mutable.MutableInt;
+
+public class FillBiomeCommand {
+    public static final SimpleCommandExceptionType ERROR_NOT_LOADED = new SimpleCommandExceptionType(Component.translatable("argument.pos.unloaded"));
+    private static final Dynamic2CommandExceptionType ERROR_VOLUME_TOO_LARGE = new Dynamic2CommandExceptionType((maximum, specified) -> {
+        return Component.translatable("commands.fillbiome.toobig", maximum, specified);
+    });
+
+    public static void register(CommandDispatcher<CommandSourceStack> dispatcher, CommandBuildContext commandRegistryAccess) {
+        dispatcher.register(Commands.literal("fillbiome").requires((source) -> {
+            return source.hasPermission(2);
+        }).then(Commands.argument("from", BlockPosArgument.blockPos()).then(Commands.argument("to", BlockPosArgument.blockPos()).then(Commands.argument("biome", ResourceArgument.resource(commandRegistryAccess, Registries.BIOME)).executes((context) -> {
+            return fill(context.getSource(), BlockPosArgument.getLoadedBlockPos(context, "from"), BlockPosArgument.getLoadedBlockPos(context, "to"), ResourceArgument.getResource(context, "biome", Registries.BIOME), (holder) -> {
+                return true;
+            });
+        }).then(Commands.literal("replace").then(Commands.argument("filter", ResourceOrTagArgument.resourceOrTag(commandRegistryAccess, Registries.BIOME)).executes((context) -> {
+            return fill(context.getSource(), BlockPosArgument.getLoadedBlockPos(context, "from"), BlockPosArgument.getLoadedBlockPos(context, "to"), ResourceArgument.getResource(context, "biome", Registries.BIOME), ResourceOrTagArgument.getResourceOrTag(context, "filter", Registries.BIOME)::test);
+        })))))));
+    }
+
+    private static int quantize(int coordinate) {
+        return QuartPos.toBlock(QuartPos.fromBlock(coordinate));
+    }
+
+    private static BlockPos quantize(BlockPos pos) {
+        return new BlockPos(quantize(pos.getX()), quantize(pos.getY()), quantize(pos.getZ()));
+    }
+
+    private static BiomeResolver makeResolver(MutableInt counter, ChunkAccess chunk, BoundingBox box, Holder<Biome> biome, Predicate<Holder<Biome>> filter) {
+        return (x, y, z, noise) -> {
+            int i = QuartPos.toBlock(x);
+            int j = QuartPos.toBlock(y);
+            int k = QuartPos.toBlock(z);
+            Holder<Biome> holder2 = chunk.getNoiseBiome(x, y, z);
+            if (box.isInside(i, j, k) && filter.test(holder2)) {
+                counter.increment();
+                return biome;
+            } else {
+                return holder2;
+            }
+        };
+    }
+
+    private static int fill(CommandSourceStack source, BlockPos from, BlockPos to, Holder.Reference<Biome> biome, Predicate<Holder<Biome>> filter) throws CommandSyntaxException {
+        BlockPos blockPos = quantize(from);
+        BlockPos blockPos2 = quantize(to);
+        BoundingBox boundingBox = BoundingBox.fromCorners(blockPos, blockPos2);
+        int i = boundingBox.getXSpan() * boundingBox.getYSpan() * boundingBox.getZSpan();
+        int j = source.getLevel().getGameRules().getInt(GameRules.RULE_COMMAND_MODIFICATION_BLOCK_LIMIT);
+        if (i > j) {
+            throw ERROR_VOLUME_TOO_LARGE.create(j, i);
+        } else {
+            ServerLevel serverLevel = source.getLevel();
+            List<ChunkAccess> list = new ArrayList<>();
+
+            for(int k = SectionPos.blockToSectionCoord(boundingBox.minZ()); k <= SectionPos.blockToSectionCoord(boundingBox.maxZ()); ++k) {
+                for(int l = SectionPos.blockToSectionCoord(boundingBox.minX()); l <= SectionPos.blockToSectionCoord(boundingBox.maxX()); ++l) {
+                    ChunkAccess chunkAccess = serverLevel.getChunk(l, k, ChunkStatus.FULL, false);
+                    if (chunkAccess == null) {
+                        throw ERROR_NOT_LOADED.create();
+                    }
+
+                    list.add(chunkAccess);
+                }
+            }
+
+            MutableInt mutableInt = new MutableInt(0);
+
+            for(ChunkAccess chunkAccess2 : list) {
+                chunkAccess2.fillBiomesFromNoise(makeResolver(mutableInt, chunkAccess2, boundingBox, biome, filter), serverLevel.getChunkSource().randomState().sampler());
+                chunkAccess2.setUnsaved(true);
+            }
+
+            serverLevel.getChunkSource().chunkMap.resendBiomesForChunks(list);
+            source.sendSuccess(() -> {
+                return Component.translatable("commands.fillbiome.success.count", mutableInt.getValue(), boundingBox.minX(), boundingBox.minY(), boundingBox.minZ(), boundingBox.maxX(), boundingBox.maxY(), boundingBox.maxZ());
+            }, true);
+            return mutableInt.getValue();
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/commands/FillCommand.java b/src/main/java/net/minecraft/server/commands/FillCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..e75b08126d9c42d49058fc91d68d1906fc277e8a
--- /dev/null
+++ b/src/main/java/net/minecraft/server/commands/FillCommand.java
@@ -0,0 +1,122 @@
+package net.minecraft.server.commands;
+
+import com.google.common.collect.Lists;
+import com.mojang.brigadier.CommandDispatcher;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import com.mojang.brigadier.exceptions.Dynamic2CommandExceptionType;
+import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
+import java.util.Collections;
+import java.util.List;
+import java.util.function.Predicate;
+import javax.annotation.Nullable;
+import net.minecraft.commands.CommandBuildContext;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.commands.Commands;
+import net.minecraft.commands.arguments.blocks.BlockInput;
+import net.minecraft.commands.arguments.blocks.BlockPredicateArgument;
+import net.minecraft.commands.arguments.blocks.BlockStateArgument;
+import net.minecraft.commands.arguments.coordinates.BlockPosArgument;
+import net.minecraft.core.BlockPos;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.network.chat.Component;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.Clearable;
+import net.minecraft.world.level.GameRules;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.entity.BlockEntity;
+import net.minecraft.world.level.block.state.pattern.BlockInWorld;
+import net.minecraft.world.level.levelgen.structure.BoundingBox;
+
+public class FillCommand {
+    private static final Dynamic2CommandExceptionType ERROR_AREA_TOO_LARGE = new Dynamic2CommandExceptionType((maxCount, count) -> {
+        return Component.translatable("commands.fill.toobig", maxCount, count);
+    });
+    static final BlockInput HOLLOW_CORE = new BlockInput(Blocks.AIR.defaultBlockState(), Collections.emptySet(), (CompoundTag)null);
+    private static final SimpleCommandExceptionType ERROR_FAILED = new SimpleCommandExceptionType(Component.translatable("commands.fill.failed"));
+
+    public static void register(CommandDispatcher<CommandSourceStack> dispatcher, CommandBuildContext commandRegistryAccess) {
+        dispatcher.register(Commands.literal("fill").requires((source) -> {
+            return source.hasPermission(2);
+        }).then(Commands.argument("from", BlockPosArgument.blockPos()).then(Commands.argument("to", BlockPosArgument.blockPos()).then(Commands.argument("block", BlockStateArgument.block(commandRegistryAccess)).executes((context) -> {
+            return fillBlocks(context.getSource(), BoundingBox.fromCorners(BlockPosArgument.getLoadedBlockPos(context, "from"), BlockPosArgument.getLoadedBlockPos(context, "to")), BlockStateArgument.getBlock(context, "block"), FillCommand.Mode.REPLACE, (Predicate<BlockInWorld>)null);
+        }).then(Commands.literal("replace").executes((context) -> {
+            return fillBlocks(context.getSource(), BoundingBox.fromCorners(BlockPosArgument.getLoadedBlockPos(context, "from"), BlockPosArgument.getLoadedBlockPos(context, "to")), BlockStateArgument.getBlock(context, "block"), FillCommand.Mode.REPLACE, (Predicate<BlockInWorld>)null);
+        }).then(Commands.argument("filter", BlockPredicateArgument.blockPredicate(commandRegistryAccess)).executes((context) -> {
+            return fillBlocks(context.getSource(), BoundingBox.fromCorners(BlockPosArgument.getLoadedBlockPos(context, "from"), BlockPosArgument.getLoadedBlockPos(context, "to")), BlockStateArgument.getBlock(context, "block"), FillCommand.Mode.REPLACE, BlockPredicateArgument.getBlockPredicate(context, "filter"));
+        }))).then(Commands.literal("keep").executes((context) -> {
+            return fillBlocks(context.getSource(), BoundingBox.fromCorners(BlockPosArgument.getLoadedBlockPos(context, "from"), BlockPosArgument.getLoadedBlockPos(context, "to")), BlockStateArgument.getBlock(context, "block"), FillCommand.Mode.REPLACE, (pos) -> {
+                return pos.getLevel().isEmptyBlock(pos.getPos());
+            });
+        })).then(Commands.literal("outline").executes((context) -> {
+            return fillBlocks(context.getSource(), BoundingBox.fromCorners(BlockPosArgument.getLoadedBlockPos(context, "from"), BlockPosArgument.getLoadedBlockPos(context, "to")), BlockStateArgument.getBlock(context, "block"), FillCommand.Mode.OUTLINE, (Predicate<BlockInWorld>)null);
+        })).then(Commands.literal("hollow").executes((context) -> {
+            return fillBlocks(context.getSource(), BoundingBox.fromCorners(BlockPosArgument.getLoadedBlockPos(context, "from"), BlockPosArgument.getLoadedBlockPos(context, "to")), BlockStateArgument.getBlock(context, "block"), FillCommand.Mode.HOLLOW, (Predicate<BlockInWorld>)null);
+        })).then(Commands.literal("destroy").executes((context) -> {
+            return fillBlocks(context.getSource(), BoundingBox.fromCorners(BlockPosArgument.getLoadedBlockPos(context, "from"), BlockPosArgument.getLoadedBlockPos(context, "to")), BlockStateArgument.getBlock(context, "block"), FillCommand.Mode.DESTROY, (Predicate<BlockInWorld>)null);
+        }))))));
+    }
+
+    private static int fillBlocks(CommandSourceStack source, BoundingBox range, BlockInput block, FillCommand.Mode mode, @Nullable Predicate<BlockInWorld> filter) throws CommandSyntaxException {
+        int i = range.getXSpan() * range.getYSpan() * range.getZSpan();
+        int j = source.getLevel().getGameRules().getInt(GameRules.RULE_COMMAND_MODIFICATION_BLOCK_LIMIT);
+        if (i > j) {
+            throw ERROR_AREA_TOO_LARGE.create(j, i);
+        } else {
+            List<BlockPos> list = Lists.newArrayList();
+            ServerLevel serverLevel = source.getLevel();
+            int k = 0;
+
+            for(BlockPos blockPos : BlockPos.betweenClosed(range.minX(), range.minY(), range.minZ(), range.maxX(), range.maxY(), range.maxZ())) {
+                if (filter == null || filter.test(new BlockInWorld(serverLevel, blockPos, true))) {
+                    BlockInput blockInput = mode.filter.filter(range, blockPos, block, serverLevel);
+                    if (blockInput != null) {
+                        BlockEntity blockEntity = serverLevel.getBlockEntity(blockPos);
+                        Clearable.tryClear(blockEntity);
+                        if (blockInput.place(serverLevel, blockPos, 2)) {
+                            list.add(blockPos.immutable());
+                            ++k;
+                        }
+                    }
+                }
+            }
+
+            for(BlockPos blockPos2 : list) {
+                Block block2 = serverLevel.getBlockState(blockPos2).getBlock();
+                serverLevel.blockUpdated(blockPos2, block2);
+            }
+
+            if (k == 0) {
+                throw ERROR_FAILED.create();
+            } else {
+                int l = k;
+                source.sendSuccess(() -> {
+                    return Component.translatable("commands.fill.success", l);
+                }, true);
+                return k;
+            }
+        }
+    }
+
+    static enum Mode {
+        REPLACE((range, pos, block, world) -> {
+            return block;
+        }),
+        OUTLINE((range, pos, block, world) -> {
+            return pos.getX() != range.minX() && pos.getX() != range.maxX() && pos.getY() != range.minY() && pos.getY() != range.maxY() && pos.getZ() != range.minZ() && pos.getZ() != range.maxZ() ? null : block;
+        }),
+        HOLLOW((range, pos, block, world) -> {
+            return pos.getX() != range.minX() && pos.getX() != range.maxX() && pos.getY() != range.minY() && pos.getY() != range.maxY() && pos.getZ() != range.minZ() && pos.getZ() != range.maxZ() ? FillCommand.HOLLOW_CORE : block;
+        }),
+        DESTROY((range, pos, block, world) -> {
+            world.destroyBlock(pos, true);
+            return block;
+        });
+
+        public final SetBlockCommand.Filter filter;
+
+        private Mode(SetBlockCommand.Filter filter) {
+            this.filter = filter;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/commands/ForceLoadCommand.java b/src/main/java/net/minecraft/server/commands/ForceLoadCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..99250f40978aa3c45df821c3d83f80b541dbb14c
--- /dev/null
+++ b/src/main/java/net/minecraft/server/commands/ForceLoadCommand.java
@@ -0,0 +1,157 @@
+package net.minecraft.server.commands;
+
+import com.google.common.base.Joiner;
+import com.mojang.brigadier.CommandDispatcher;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import com.mojang.brigadier.exceptions.Dynamic2CommandExceptionType;
+import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
+import it.unimi.dsi.fastutil.longs.LongSet;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.commands.Commands;
+import net.minecraft.commands.arguments.coordinates.BlockPosArgument;
+import net.minecraft.commands.arguments.coordinates.ColumnPosArgument;
+import net.minecraft.core.SectionPos;
+import net.minecraft.network.chat.Component;
+import net.minecraft.resources.ResourceKey;
+import net.minecraft.server.level.ColumnPos;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.Level;
+
+public class ForceLoadCommand {
+    private static final int MAX_CHUNK_LIMIT = 256;
+    private static final Dynamic2CommandExceptionType ERROR_TOO_MANY_CHUNKS = new Dynamic2CommandExceptionType((maxCount, count) -> {
+        return Component.translatable("commands.forceload.toobig", maxCount, count);
+    });
+    private static final Dynamic2CommandExceptionType ERROR_NOT_TICKING = new Dynamic2CommandExceptionType((chunkPos, registryKey) -> {
+        return Component.translatable("commands.forceload.query.failure", chunkPos, registryKey);
+    });
+    private static final SimpleCommandExceptionType ERROR_ALL_ADDED = new SimpleCommandExceptionType(Component.translatable("commands.forceload.added.failure"));
+    private static final SimpleCommandExceptionType ERROR_NONE_REMOVED = new SimpleCommandExceptionType(Component.translatable("commands.forceload.removed.failure"));
+
+    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
+        dispatcher.register(Commands.literal("forceload").requires((source) -> {
+            return source.hasPermission(2);
+        }).then(Commands.literal("add").then(Commands.argument("from", ColumnPosArgument.columnPos()).executes((context) -> {
+            return changeForceLoad(context.getSource(), ColumnPosArgument.getColumnPos(context, "from"), ColumnPosArgument.getColumnPos(context, "from"), true);
+        }).then(Commands.argument("to", ColumnPosArgument.columnPos()).executes((context) -> {
+            return changeForceLoad(context.getSource(), ColumnPosArgument.getColumnPos(context, "from"), ColumnPosArgument.getColumnPos(context, "to"), true);
+        })))).then(Commands.literal("remove").then(Commands.argument("from", ColumnPosArgument.columnPos()).executes((context) -> {
+            return changeForceLoad(context.getSource(), ColumnPosArgument.getColumnPos(context, "from"), ColumnPosArgument.getColumnPos(context, "from"), false);
+        }).then(Commands.argument("to", ColumnPosArgument.columnPos()).executes((context) -> {
+            return changeForceLoad(context.getSource(), ColumnPosArgument.getColumnPos(context, "from"), ColumnPosArgument.getColumnPos(context, "to"), false);
+        }))).then(Commands.literal("all").executes((context) -> {
+            return removeAll(context.getSource());
+        }))).then(Commands.literal("query").executes((context) -> {
+            return listForceLoad(context.getSource());
+        }).then(Commands.argument("pos", ColumnPosArgument.columnPos()).executes((context) -> {
+            return queryForceLoad(context.getSource(), ColumnPosArgument.getColumnPos(context, "pos"));
+        }))));
+    }
+
+    private static int queryForceLoad(CommandSourceStack source, ColumnPos pos) throws CommandSyntaxException {
+        ChunkPos chunkPos = pos.toChunkPos();
+        ServerLevel serverLevel = source.getLevel();
+        ResourceKey<Level> resourceKey = serverLevel.dimension();
+        boolean bl = serverLevel.getForcedChunks().contains(chunkPos.toLong());
+        if (bl) {
+            source.sendSuccess(() -> {
+                return Component.translatable("commands.forceload.query.success", chunkPos, resourceKey.location());
+            }, false);
+            return 1;
+        } else {
+            throw ERROR_NOT_TICKING.create(chunkPos, resourceKey.location());
+        }
+    }
+
+    private static int listForceLoad(CommandSourceStack source) {
+        ServerLevel serverLevel = source.getLevel();
+        ResourceKey<Level> resourceKey = serverLevel.dimension();
+        LongSet longSet = serverLevel.getForcedChunks();
+        int i = longSet.size();
+        if (i > 0) {
+            String string = Joiner.on(", ").join(longSet.stream().sorted().map(ChunkPos::new).map(ChunkPos::toString).iterator());
+            if (i == 1) {
+                source.sendSuccess(() -> {
+                    return Component.translatable("commands.forceload.list.single", resourceKey.location(), string);
+                }, false);
+            } else {
+                source.sendSuccess(() -> {
+                    return Component.translatable("commands.forceload.list.multiple", i, resourceKey.location(), string);
+                }, false);
+            }
+        } else {
+            source.sendFailure(Component.translatable("commands.forceload.added.none", resourceKey.location()));
+        }
+
+        return i;
+    }
+
+    private static int removeAll(CommandSourceStack source) {
+        ServerLevel serverLevel = source.getLevel();
+        ResourceKey<Level> resourceKey = serverLevel.dimension();
+        LongSet longSet = serverLevel.getForcedChunks();
+        longSet.forEach((chunkPos) -> {
+            serverLevel.setChunkForced(ChunkPos.getX(chunkPos), ChunkPos.getZ(chunkPos), false);
+        });
+        source.sendSuccess(() -> {
+            return Component.translatable("commands.forceload.removed.all", resourceKey.location());
+        }, true);
+        return 0;
+    }
+
+    private static int changeForceLoad(CommandSourceStack source, ColumnPos from, ColumnPos to, boolean forceLoaded) throws CommandSyntaxException {
+        int i = Math.min(from.x(), to.x());
+        int j = Math.min(from.z(), to.z());
+        int k = Math.max(from.x(), to.x());
+        int l = Math.max(from.z(), to.z());
+        if (i >= -30000000 && j >= -30000000 && k < 30000000 && l < 30000000) {
+            int m = SectionPos.blockToSectionCoord(i);
+            int n = SectionPos.blockToSectionCoord(j);
+            int o = SectionPos.blockToSectionCoord(k);
+            int p = SectionPos.blockToSectionCoord(l);
+            long q = ((long)(o - m) + 1L) * ((long)(p - n) + 1L);
+            if (q > 256L) {
+                throw ERROR_TOO_MANY_CHUNKS.create(256, q);
+            } else {
+                ServerLevel serverLevel = source.getLevel();
+                ResourceKey<Level> resourceKey = serverLevel.dimension();
+                ChunkPos chunkPos = null;
+                int r = 0;
+
+                for(int s = m; s <= o; ++s) {
+                    for(int t = n; t <= p; ++t) {
+                        boolean bl = serverLevel.setChunkForced(s, t, forceLoaded);
+                        if (bl) {
+                            ++r;
+                            if (chunkPos == null) {
+                                chunkPos = new ChunkPos(s, t);
+                            }
+                        }
+                    }
+                }
+
+                ChunkPos chunkPos2 = chunkPos;
+                if (r == 0) {
+                    throw (forceLoaded ? ERROR_ALL_ADDED : ERROR_NONE_REMOVED).create();
+                } else {
+                    if (r == 1) {
+                        source.sendSuccess(() -> {
+                            return Component.translatable("commands.forceload." + (forceLoaded ? "added" : "removed") + ".single", chunkPos2, resourceKey.location());
+                        }, true);
+                    } else {
+                        ChunkPos chunkPos3 = new ChunkPos(m, n);
+                        ChunkPos chunkPos4 = new ChunkPos(o, p);
+                        source.sendSuccess(() -> {
+                            return Component.translatable("commands.forceload." + (forceLoaded ? "added" : "removed") + ".multiple", chunkPos2, resourceKey.location(), chunkPos3, chunkPos4);
+                        }, true);
+                    }
+
+                    return r;
+                }
+            }
+        } else {
+            throw BlockPosArgument.ERROR_OUT_OF_WORLD.create();
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/commands/KillCommand.java b/src/main/java/net/minecraft/server/commands/KillCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..0026da50714adca207b1d3970ee808c9c09d4443
--- /dev/null
+++ b/src/main/java/net/minecraft/server/commands/KillCommand.java
@@ -0,0 +1,40 @@
+package net.minecraft.server.commands;
+
+import com.google.common.collect.ImmutableList;
+import com.mojang.brigadier.CommandDispatcher;
+import java.util.Collection;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.commands.Commands;
+import net.minecraft.commands.arguments.EntityArgument;
+import net.minecraft.network.chat.Component;
+import net.minecraft.world.entity.Entity;
+
+public class KillCommand {
+    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
+        dispatcher.register(Commands.literal("kill").requires((source) -> {
+            return source.hasPermission(2);
+        }).executes((context) -> {
+            return kill(context.getSource(), ImmutableList.of(context.getSource().getEntityOrException()));
+        }).then(Commands.argument("targets", EntityArgument.entities()).executes((context) -> {
+            return kill(context.getSource(), EntityArgument.getEntities(context, "targets"));
+        })));
+    }
+
+    private static int kill(CommandSourceStack source, Collection<? extends Entity> targets) {
+        for(Entity entity : targets) {
+            entity.kill();
+        }
+
+        if (targets.size() == 1) {
+            source.sendSuccess(() -> {
+                return Component.translatable("commands.kill.success.single", targets.iterator().next().getDisplayName());
+            }, true);
+        } else {
+            source.sendSuccess(() -> {
+                return Component.translatable("commands.kill.success.multiple", targets.size());
+            }, true);
+        }
+
+        return targets.size();
+    }
+}
diff --git a/src/main/java/net/minecraft/server/commands/PlaceCommand.java b/src/main/java/net/minecraft/server/commands/PlaceCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..a5031c06b0215b8196c4b1b5330c318617adf3d5
--- /dev/null
+++ b/src/main/java/net/minecraft/server/commands/PlaceCommand.java
@@ -0,0 +1,179 @@
+package net.minecraft.server.commands;
+
+import com.mojang.brigadier.CommandDispatcher;
+import com.mojang.brigadier.arguments.FloatArgumentType;
+import com.mojang.brigadier.arguments.IntegerArgumentType;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import com.mojang.brigadier.exceptions.DynamicCommandExceptionType;
+import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
+import com.mojang.brigadier.suggestion.SuggestionProvider;
+import java.util.Optional;
+import net.minecraft.ResourceLocationException;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.commands.Commands;
+import net.minecraft.commands.SharedSuggestionProvider;
+import net.minecraft.commands.arguments.ResourceKeyArgument;
+import net.minecraft.commands.arguments.ResourceLocationArgument;
+import net.minecraft.commands.arguments.TemplateMirrorArgument;
+import net.minecraft.commands.arguments.TemplateRotationArgument;
+import net.minecraft.commands.arguments.coordinates.BlockPosArgument;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Holder;
+import net.minecraft.core.SectionPos;
+import net.minecraft.core.registries.Registries;
+import net.minecraft.network.chat.Component;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.block.Mirror;
+import net.minecraft.world.level.block.Rotation;
+import net.minecraft.world.level.block.entity.StructureBlockEntity;
+import net.minecraft.world.level.chunk.ChunkGenerator;
+import net.minecraft.world.level.levelgen.feature.ConfiguredFeature;
+import net.minecraft.world.level.levelgen.structure.BoundingBox;
+import net.minecraft.world.level.levelgen.structure.Structure;
+import net.minecraft.world.level.levelgen.structure.StructureStart;
+import net.minecraft.world.level.levelgen.structure.pools.JigsawPlacement;
+import net.minecraft.world.level.levelgen.structure.pools.StructureTemplatePool;
+import net.minecraft.world.level.levelgen.structure.templatesystem.BlockRotProcessor;
+import net.minecraft.world.level.levelgen.structure.templatesystem.StructurePlaceSettings;
+import net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate;
+import net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplateManager;
+
+public class PlaceCommand {
+    private static final SimpleCommandExceptionType ERROR_FEATURE_FAILED = new SimpleCommandExceptionType(Component.translatable("commands.place.feature.failed"));
+    private static final SimpleCommandExceptionType ERROR_JIGSAW_FAILED = new SimpleCommandExceptionType(Component.translatable("commands.place.jigsaw.failed"));
+    private static final SimpleCommandExceptionType ERROR_STRUCTURE_FAILED = new SimpleCommandExceptionType(Component.translatable("commands.place.structure.failed"));
+    private static final DynamicCommandExceptionType ERROR_TEMPLATE_INVALID = new DynamicCommandExceptionType((id) -> {
+        return Component.translatable("commands.place.template.invalid", id);
+    });
+    private static final SimpleCommandExceptionType ERROR_TEMPLATE_FAILED = new SimpleCommandExceptionType(Component.translatable("commands.place.template.failed"));
+    private static final SuggestionProvider<CommandSourceStack> SUGGEST_TEMPLATES = (context, builder) -> {
+        StructureTemplateManager structureTemplateManager = context.getSource().getLevel().getStructureManager();
+        return SharedSuggestionProvider.suggestResource(structureTemplateManager.listTemplates(), builder);
+    };
+
+    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
+        dispatcher.register(Commands.literal("place").requires((source) -> {
+            return source.hasPermission(2);
+        }).then(Commands.literal("feature").then(Commands.argument("feature", ResourceKeyArgument.key(Registries.CONFIGURED_FEATURE)).executes((context) -> {
+            return placeFeature(context.getSource(), ResourceKeyArgument.getConfiguredFeature(context, "feature"), BlockPos.containing(context.getSource().getPosition()));
+        }).then(Commands.argument("pos", BlockPosArgument.blockPos()).executes((context) -> {
+            return placeFeature(context.getSource(), ResourceKeyArgument.getConfiguredFeature(context, "feature"), BlockPosArgument.getLoadedBlockPos(context, "pos"));
+        })))).then(Commands.literal("jigsaw").then(Commands.argument("pool", ResourceKeyArgument.key(Registries.TEMPLATE_POOL)).then(Commands.argument("target", ResourceLocationArgument.id()).then(Commands.argument("max_depth", IntegerArgumentType.integer(1, 7)).executes((context) -> {
+            return placeJigsaw(context.getSource(), ResourceKeyArgument.getStructureTemplatePool(context, "pool"), ResourceLocationArgument.getId(context, "target"), IntegerArgumentType.getInteger(context, "max_depth"), BlockPos.containing(context.getSource().getPosition()));
+        }).then(Commands.argument("position", BlockPosArgument.blockPos()).executes((context) -> {
+            return placeJigsaw(context.getSource(), ResourceKeyArgument.getStructureTemplatePool(context, "pool"), ResourceLocationArgument.getId(context, "target"), IntegerArgumentType.getInteger(context, "max_depth"), BlockPosArgument.getLoadedBlockPos(context, "position"));
+        })))))).then(Commands.literal("structure").then(Commands.argument("structure", ResourceKeyArgument.key(Registries.STRUCTURE)).executes((context) -> {
+            return placeStructure(context.getSource(), ResourceKeyArgument.getStructure(context, "structure"), BlockPos.containing(context.getSource().getPosition()));
+        }).then(Commands.argument("pos", BlockPosArgument.blockPos()).executes((context) -> {
+            return placeStructure(context.getSource(), ResourceKeyArgument.getStructure(context, "structure"), BlockPosArgument.getLoadedBlockPos(context, "pos"));
+        })))).then(Commands.literal("template").then(Commands.argument("template", ResourceLocationArgument.id()).suggests(SUGGEST_TEMPLATES).executes((context) -> {
+            return placeTemplate(context.getSource(), ResourceLocationArgument.getId(context, "template"), BlockPos.containing(context.getSource().getPosition()), Rotation.NONE, Mirror.NONE, 1.0F, 0);
+        }).then(Commands.argument("pos", BlockPosArgument.blockPos()).executes((context) -> {
+            return placeTemplate(context.getSource(), ResourceLocationArgument.getId(context, "template"), BlockPosArgument.getLoadedBlockPos(context, "pos"), Rotation.NONE, Mirror.NONE, 1.0F, 0);
+        }).then(Commands.argument("rotation", TemplateRotationArgument.templateRotation()).executes((context) -> {
+            return placeTemplate(context.getSource(), ResourceLocationArgument.getId(context, "template"), BlockPosArgument.getLoadedBlockPos(context, "pos"), TemplateRotationArgument.getRotation(context, "rotation"), Mirror.NONE, 1.0F, 0);
+        }).then(Commands.argument("mirror", TemplateMirrorArgument.templateMirror()).executes((context) -> {
+            return placeTemplate(context.getSource(), ResourceLocationArgument.getId(context, "template"), BlockPosArgument.getLoadedBlockPos(context, "pos"), TemplateRotationArgument.getRotation(context, "rotation"), TemplateMirrorArgument.getMirror(context, "mirror"), 1.0F, 0);
+        }).then(Commands.argument("integrity", FloatArgumentType.floatArg(0.0F, 1.0F)).executes((context) -> {
+            return placeTemplate(context.getSource(), ResourceLocationArgument.getId(context, "template"), BlockPosArgument.getLoadedBlockPos(context, "pos"), TemplateRotationArgument.getRotation(context, "rotation"), TemplateMirrorArgument.getMirror(context, "mirror"), FloatArgumentType.getFloat(context, "integrity"), 0);
+        }).then(Commands.argument("seed", IntegerArgumentType.integer()).executes((context) -> {
+            return placeTemplate(context.getSource(), ResourceLocationArgument.getId(context, "template"), BlockPosArgument.getLoadedBlockPos(context, "pos"), TemplateRotationArgument.getRotation(context, "rotation"), TemplateMirrorArgument.getMirror(context, "mirror"), FloatArgumentType.getFloat(context, "integrity"), IntegerArgumentType.getInteger(context, "seed"));
+        })))))))));
+    }
+
+    public static int placeFeature(CommandSourceStack source, Holder.Reference<ConfiguredFeature<?, ?>> feature, BlockPos pos) throws CommandSyntaxException {
+        ServerLevel serverLevel = source.getLevel();
+        ConfiguredFeature<?, ?> configuredFeature = feature.value();
+        ChunkPos chunkPos = new ChunkPos(pos);
+        checkLoaded(serverLevel, new ChunkPos(chunkPos.x - 1, chunkPos.z - 1), new ChunkPos(chunkPos.x + 1, chunkPos.z + 1));
+        if (!configuredFeature.place(serverLevel, serverLevel.getChunkSource().getGenerator(), serverLevel.getRandom(), pos)) {
+            throw ERROR_FEATURE_FAILED.create();
+        } else {
+            String string = feature.key().location().toString();
+            source.sendSuccess(() -> {
+                return Component.translatable("commands.place.feature.success", string, pos.getX(), pos.getY(), pos.getZ());
+            }, true);
+            return 1;
+        }
+    }
+
+    public static int placeJigsaw(CommandSourceStack source, Holder<StructureTemplatePool> structurePool, ResourceLocation id, int maxDepth, BlockPos pos) throws CommandSyntaxException {
+        ServerLevel serverLevel = source.getLevel();
+        if (!JigsawPlacement.generateJigsaw(serverLevel, structurePool, id, maxDepth, pos, false)) {
+            throw ERROR_JIGSAW_FAILED.create();
+        } else {
+            source.sendSuccess(() -> {
+                return Component.translatable("commands.place.jigsaw.success", pos.getX(), pos.getY(), pos.getZ());
+            }, true);
+            return 1;
+        }
+    }
+
+    public static int placeStructure(CommandSourceStack source, Holder.Reference<Structure> structure, BlockPos pos) throws CommandSyntaxException {
+        ServerLevel serverLevel = source.getLevel();
+        Structure structure2 = structure.value();
+        ChunkGenerator chunkGenerator = serverLevel.getChunkSource().getGenerator();
+        StructureStart structureStart = structure2.generate(source.registryAccess(), chunkGenerator, chunkGenerator.getBiomeSource(), serverLevel.getChunkSource().randomState(), serverLevel.getStructureManager(), serverLevel.getSeed(), new ChunkPos(pos), 0, serverLevel, (biome) -> {
+            return true;
+        });
+        if (!structureStart.isValid()) {
+            throw ERROR_STRUCTURE_FAILED.create();
+        } else {
+            BoundingBox boundingBox = structureStart.getBoundingBox();
+            ChunkPos chunkPos = new ChunkPos(SectionPos.blockToSectionCoord(boundingBox.minX()), SectionPos.blockToSectionCoord(boundingBox.minZ()));
+            ChunkPos chunkPos2 = new ChunkPos(SectionPos.blockToSectionCoord(boundingBox.maxX()), SectionPos.blockToSectionCoord(boundingBox.maxZ()));
+            checkLoaded(serverLevel, chunkPos, chunkPos2);
+            ChunkPos.rangeClosed(chunkPos, chunkPos2).forEach((chunkPosx) -> {
+                structureStart.placeInChunk(serverLevel, serverLevel.structureManager(), chunkGenerator, serverLevel.getRandom(), new BoundingBox(chunkPosx.getMinBlockX(), serverLevel.getMinBuildHeight(), chunkPosx.getMinBlockZ(), chunkPosx.getMaxBlockX(), serverLevel.getMaxBuildHeight(), chunkPosx.getMaxBlockZ()), chunkPosx);
+            });
+            String string = structure.key().location().toString();
+            source.sendSuccess(() -> {
+                return Component.translatable("commands.place.structure.success", string, pos.getX(), pos.getY(), pos.getZ());
+            }, true);
+            return 1;
+        }
+    }
+
+    public static int placeTemplate(CommandSourceStack source, ResourceLocation id, BlockPos pos, Rotation rotation, Mirror mirror, float integrity, int seed) throws CommandSyntaxException {
+        ServerLevel serverLevel = source.getLevel();
+        StructureTemplateManager structureTemplateManager = serverLevel.getStructureManager();
+
+        Optional<StructureTemplate> optional;
+        try {
+            optional = structureTemplateManager.get(id);
+        } catch (ResourceLocationException var13) {
+            throw ERROR_TEMPLATE_INVALID.create(id);
+        }
+
+        if (optional.isEmpty()) {
+            throw ERROR_TEMPLATE_INVALID.create(id);
+        } else {
+            StructureTemplate structureTemplate = optional.get();
+            checkLoaded(serverLevel, new ChunkPos(pos), new ChunkPos(pos.offset(structureTemplate.getSize())));
+            StructurePlaceSettings structurePlaceSettings = (new StructurePlaceSettings()).setMirror(mirror).setRotation(rotation);
+            if (integrity < 1.0F) {
+                structurePlaceSettings.clearProcessors().addProcessor(new BlockRotProcessor(integrity)).setRandom(StructureBlockEntity.createRandom((long)seed));
+            }
+
+            boolean bl = structureTemplate.placeInWorld(serverLevel, pos, pos, structurePlaceSettings, StructureBlockEntity.createRandom((long)seed), 2);
+            if (!bl) {
+                throw ERROR_TEMPLATE_FAILED.create();
+            } else {
+                source.sendSuccess(() -> {
+                    return Component.translatable("commands.place.template.success", id, pos.getX(), pos.getY(), pos.getZ());
+                }, true);
+                return 1;
+            }
+        }
+    }
+
+    private static void checkLoaded(ServerLevel world, ChunkPos pos1, ChunkPos pos2) throws CommandSyntaxException {
+        if (ChunkPos.rangeClosed(pos1, pos2).filter((pos) -> {
+            return !world.isLoaded(pos.getWorldPosition());
+        }).findAny().isPresent()) {
+            throw BlockPosArgument.ERROR_NOT_LOADED.create();
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/commands/RecipeCommand.java b/src/main/java/net/minecraft/server/commands/RecipeCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..55302ad238062a9505464d20b39cce203270a1e5
--- /dev/null
+++ b/src/main/java/net/minecraft/server/commands/RecipeCommand.java
@@ -0,0 +1,82 @@
+package net.minecraft.server.commands;
+
+import com.mojang.brigadier.CommandDispatcher;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
+import java.util.Collection;
+import java.util.Collections;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.commands.Commands;
+import net.minecraft.commands.arguments.EntityArgument;
+import net.minecraft.commands.arguments.ResourceLocationArgument;
+import net.minecraft.commands.synchronization.SuggestionProviders;
+import net.minecraft.network.chat.Component;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.item.crafting.Recipe;
+
+public class RecipeCommand {
+    private static final SimpleCommandExceptionType ERROR_GIVE_FAILED = new SimpleCommandExceptionType(Component.translatable("commands.recipe.give.failed"));
+    private static final SimpleCommandExceptionType ERROR_TAKE_FAILED = new SimpleCommandExceptionType(Component.translatable("commands.recipe.take.failed"));
+
+    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
+        dispatcher.register(Commands.literal("recipe").requires((source) -> {
+            return source.hasPermission(2);
+        }).then(Commands.literal("give").then(Commands.argument("targets", EntityArgument.players()).then(Commands.argument("recipe", ResourceLocationArgument.id()).suggests(SuggestionProviders.ALL_RECIPES).executes((context) -> {
+            return giveRecipes(context.getSource(), EntityArgument.getPlayers(context, "targets"), Collections.singleton(ResourceLocationArgument.getRecipe(context, "recipe")));
+        })).then(Commands.literal("*").executes((context) -> {
+            return giveRecipes(context.getSource(), EntityArgument.getPlayers(context, "targets"), context.getSource().getServer().getRecipeManager().getRecipes());
+        })))).then(Commands.literal("take").then(Commands.argument("targets", EntityArgument.players()).then(Commands.argument("recipe", ResourceLocationArgument.id()).suggests(SuggestionProviders.ALL_RECIPES).executes((context) -> {
+            return takeRecipes(context.getSource(), EntityArgument.getPlayers(context, "targets"), Collections.singleton(ResourceLocationArgument.getRecipe(context, "recipe")));
+        })).then(Commands.literal("*").executes((context) -> {
+            return takeRecipes(context.getSource(), EntityArgument.getPlayers(context, "targets"), context.getSource().getServer().getRecipeManager().getRecipes());
+        })))));
+    }
+
+    private static int giveRecipes(CommandSourceStack source, Collection<ServerPlayer> targets, Collection<Recipe<?>> recipes) throws CommandSyntaxException {
+        int i = 0;
+
+        for(ServerPlayer serverPlayer : targets) {
+            i += serverPlayer.awardRecipes(recipes);
+        }
+
+        if (i == 0) {
+            throw ERROR_GIVE_FAILED.create();
+        } else {
+            if (targets.size() == 1) {
+                source.sendSuccess(() -> {
+                    return Component.translatable("commands.recipe.give.success.single", recipes.size(), targets.iterator().next().getDisplayName());
+                }, true);
+            } else {
+                source.sendSuccess(() -> {
+                    return Component.translatable("commands.recipe.give.success.multiple", recipes.size(), targets.size());
+                }, true);
+            }
+
+            return i;
+        }
+    }
+
+    private static int takeRecipes(CommandSourceStack source, Collection<ServerPlayer> targets, Collection<Recipe<?>> recipes) throws CommandSyntaxException {
+        int i = 0;
+
+        for(ServerPlayer serverPlayer : targets) {
+            i += serverPlayer.resetRecipes(recipes);
+        }
+
+        if (i == 0) {
+            throw ERROR_TAKE_FAILED.create();
+        } else {
+            if (targets.size() == 1) {
+                source.sendSuccess(() -> {
+                    return Component.translatable("commands.recipe.take.success.single", recipes.size(), targets.iterator().next().getDisplayName());
+                }, true);
+            } else {
+                source.sendSuccess(() -> {
+                    return Component.translatable("commands.recipe.take.success.multiple", recipes.size(), targets.size());
+                }, true);
+            }
+
+            return i;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/commands/SetBlockCommand.java b/src/main/java/net/minecraft/server/commands/SetBlockCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..342d7c12a26c6a211aae3db03ec3029c68ef650c
--- /dev/null
+++ b/src/main/java/net/minecraft/server/commands/SetBlockCommand.java
@@ -0,0 +1,77 @@
+package net.minecraft.server.commands;
+
+import com.mojang.brigadier.CommandDispatcher;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
+import java.util.function.Predicate;
+import javax.annotation.Nullable;
+import net.minecraft.commands.CommandBuildContext;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.commands.Commands;
+import net.minecraft.commands.arguments.blocks.BlockInput;
+import net.minecraft.commands.arguments.blocks.BlockStateArgument;
+import net.minecraft.commands.arguments.coordinates.BlockPosArgument;
+import net.minecraft.core.BlockPos;
+import net.minecraft.network.chat.Component;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.Clearable;
+import net.minecraft.world.level.block.entity.BlockEntity;
+import net.minecraft.world.level.block.state.pattern.BlockInWorld;
+import net.minecraft.world.level.levelgen.structure.BoundingBox;
+
+public class SetBlockCommand {
+    private static final SimpleCommandExceptionType ERROR_FAILED = new SimpleCommandExceptionType(Component.translatable("commands.setblock.failed"));
+
+    public static void register(CommandDispatcher<CommandSourceStack> dispatcher, CommandBuildContext commandRegistryAccess) {
+        dispatcher.register(Commands.literal("setblock").requires((source) -> {
+            return source.hasPermission(2);
+        }).then(Commands.argument("pos", BlockPosArgument.blockPos()).then(Commands.argument("block", BlockStateArgument.block(commandRegistryAccess)).executes((context) -> {
+            return setBlock(context.getSource(), BlockPosArgument.getLoadedBlockPos(context, "pos"), BlockStateArgument.getBlock(context, "block"), SetBlockCommand.Mode.REPLACE, (Predicate<BlockInWorld>)null);
+        }).then(Commands.literal("destroy").executes((context) -> {
+            return setBlock(context.getSource(), BlockPosArgument.getLoadedBlockPos(context, "pos"), BlockStateArgument.getBlock(context, "block"), SetBlockCommand.Mode.DESTROY, (Predicate<BlockInWorld>)null);
+        })).then(Commands.literal("keep").executes((context) -> {
+            return setBlock(context.getSource(), BlockPosArgument.getLoadedBlockPos(context, "pos"), BlockStateArgument.getBlock(context, "block"), SetBlockCommand.Mode.REPLACE, (pos) -> {
+                return pos.getLevel().isEmptyBlock(pos.getPos());
+            });
+        })).then(Commands.literal("replace").executes((context) -> {
+            return setBlock(context.getSource(), BlockPosArgument.getLoadedBlockPos(context, "pos"), BlockStateArgument.getBlock(context, "block"), SetBlockCommand.Mode.REPLACE, (Predicate<BlockInWorld>)null);
+        })))));
+    }
+
+    private static int setBlock(CommandSourceStack source, BlockPos pos, BlockInput block, SetBlockCommand.Mode mode, @Nullable Predicate<BlockInWorld> condition) throws CommandSyntaxException {
+        ServerLevel serverLevel = source.getLevel();
+        if (condition != null && !condition.test(new BlockInWorld(serverLevel, pos, true))) {
+            throw ERROR_FAILED.create();
+        } else {
+            boolean bl;
+            if (mode == SetBlockCommand.Mode.DESTROY) {
+                serverLevel.destroyBlock(pos, true);
+                bl = !block.getState().isAir() || !serverLevel.getBlockState(pos).isAir();
+            } else {
+                BlockEntity blockEntity = serverLevel.getBlockEntity(pos);
+                Clearable.tryClear(blockEntity);
+                bl = true;
+            }
+
+            if (bl && !block.place(serverLevel, pos, 2)) {
+                throw ERROR_FAILED.create();
+            } else {
+                serverLevel.blockUpdated(pos, block.getState().getBlock());
+                source.sendSuccess(() -> {
+                    return Component.translatable("commands.setblock.success", pos.getX(), pos.getY(), pos.getZ());
+                }, true);
+                return 1;
+            }
+        }
+    }
+
+    public interface Filter {
+        @Nullable
+        BlockInput filter(BoundingBox box, BlockPos pos, BlockInput block, ServerLevel world);
+    }
+
+    public static enum Mode {
+        REPLACE,
+        DESTROY;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/commands/WeatherCommand.java b/src/main/java/net/minecraft/server/commands/WeatherCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..8f5714221bc32fb2c9201cbc8a0a35610977f574
--- /dev/null
+++ b/src/main/java/net/minecraft/server/commands/WeatherCommand.java
@@ -0,0 +1,60 @@
+package net.minecraft.server.commands;
+
+import com.mojang.brigadier.CommandDispatcher;
+import com.mojang.brigadier.arguments.IntegerArgumentType;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.commands.Commands;
+import net.minecraft.commands.arguments.TimeArgument;
+import net.minecraft.network.chat.Component;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.util.valueproviders.IntProvider;
+
+public class WeatherCommand {
+    private static final int DEFAULT_TIME = -1;
+
+    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
+        dispatcher.register(Commands.literal("weather").requires((source) -> {
+            return source.hasPermission(2);
+        }).then(Commands.literal("clear").executes((context) -> {
+            return setClear(context.getSource(), -1);
+        }).then(Commands.argument("duration", TimeArgument.time(1)).executes((context) -> {
+            return setClear(context.getSource(), IntegerArgumentType.getInteger(context, "duration"));
+        }))).then(Commands.literal("rain").executes((context) -> {
+            return setRain(context.getSource(), -1);
+        }).then(Commands.argument("duration", TimeArgument.time(1)).executes((context) -> {
+            return setRain(context.getSource(), IntegerArgumentType.getInteger(context, "duration"));
+        }))).then(Commands.literal("thunder").executes((context) -> {
+            return setThunder(context.getSource(), -1);
+        }).then(Commands.argument("duration", TimeArgument.time(1)).executes((context) -> {
+            return setThunder(context.getSource(), IntegerArgumentType.getInteger(context, "duration"));
+        }))));
+    }
+
+    private static int getDuration(CommandSourceStack source, int duration, IntProvider provider) {
+        return duration == -1 ? provider.sample(source.getLevel().getRandom()) : duration;
+    }
+
+    private static int setClear(CommandSourceStack source, int duration) {
+        source.getLevel().setWeatherParameters(getDuration(source, duration, ServerLevel.RAIN_DELAY), 0, false, false);
+        source.sendSuccess(() -> {
+            return Component.translatable("commands.weather.set.clear");
+        }, true);
+        return duration;
+    }
+
+    private static int setRain(CommandSourceStack source, int duration) {
+        source.getLevel().setWeatherParameters(0, getDuration(source, duration, ServerLevel.RAIN_DURATION), true, false);
+        source.sendSuccess(() -> {
+            return Component.translatable("commands.weather.set.rain");
+        }, true);
+        return duration;
+    }
+
+    private static int setThunder(CommandSourceStack source, int duration) {
+        source.getLevel().setWeatherParameters(0, getDuration(source, duration, ServerLevel.THUNDER_DURATION), true, true);
+        source.sendSuccess(() -> {
+            return Component.translatable("commands.weather.set.thunder");
+        }, true);
+        return duration;
+    }
+}
diff --git a/src/main/java/net/minecraft/world/damagesource/CombatTracker.java b/src/main/java/net/minecraft/world/damagesource/CombatTracker.java
new file mode 100644
index 0000000000000000000000000000000000000000..c12d7bacf2c54f268b1bc5e46250a083ca041415
--- /dev/null
+++ b/src/main/java/net/minecraft/world/damagesource/CombatTracker.java
@@ -0,0 +1,162 @@
+package net.minecraft.world.damagesource;
+
+import com.google.common.collect.Lists;
+import java.util.List;
+import java.util.Objects;
+import javax.annotation.Nullable;
+import net.minecraft.network.chat.ClickEvent;
+import net.minecraft.network.chat.Component;
+import net.minecraft.network.chat.ComponentUtils;
+import net.minecraft.network.chat.HoverEvent;
+import net.minecraft.network.chat.Style;
+import net.minecraft.tags.DamageTypeTags;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.item.ItemStack;
+
+public class CombatTracker {
+    public static final int RESET_DAMAGE_STATUS_TIME = 100;
+    public static final int RESET_COMBAT_STATUS_TIME = 300;
+    private static final Style INTENTIONAL_GAME_DESIGN_STYLE = Style.EMPTY.withClickEvent(new ClickEvent(ClickEvent.Action.OPEN_URL, "https://bugs.mojang.com/browse/MCPE-28723")).withHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, Component.literal("MCPE-28723")));
+    private final List<CombatEntry> entries = Lists.newArrayList();
+    private final LivingEntity mob;
+    private int lastDamageTime;
+    private int combatStartTime;
+    private int combatEndTime;
+    private boolean inCombat;
+    private boolean takingDamage;
+
+    public CombatTracker(LivingEntity entity) {
+        this.mob = entity;
+    }
+
+    public void recordDamage(DamageSource damageSource, float originalHealth) {
+        this.recheckStatus();
+        FallLocation fallLocation = FallLocation.getCurrentFallLocation(this.mob);
+        CombatEntry combatEntry = new CombatEntry(damageSource, originalHealth, fallLocation, this.mob.fallDistance);
+        this.entries.add(combatEntry);
+        this.lastDamageTime = this.mob.tickCount;
+        this.takingDamage = true;
+        if (!this.inCombat && this.mob.isAlive() && shouldEnterCombat(damageSource)) {
+            this.inCombat = true;
+            this.combatStartTime = this.mob.tickCount;
+            this.combatEndTime = this.combatStartTime;
+            this.mob.onEnterCombat();
+        }
+
+    }
+
+    private static boolean shouldEnterCombat(DamageSource damageSource) {
+        return damageSource.getEntity() instanceof LivingEntity;
+    }
+
+    private Component getMessageForAssistedFall(Entity attacker, Component attackerDisplayName, String itemDeathTranslationKey, String deathTranslationKey) {
+        ItemStack var10000;
+        if (attacker instanceof LivingEntity livingEntity) {
+            var10000 = livingEntity.getMainHandItem();
+        } else {
+            var10000 = ItemStack.EMPTY;
+        }
+
+        ItemStack itemStack = var10000;
+        return !itemStack.isEmpty() && itemStack.hasCustomHoverName() ? Component.translatable(itemDeathTranslationKey, this.mob.getDisplayName(), attackerDisplayName, itemStack.getDisplayName()) : Component.translatable(deathTranslationKey, this.mob.getDisplayName(), attackerDisplayName);
+    }
+
+    private Component getFallMessage(CombatEntry damageRecord, @Nullable Entity attacker) {
+        DamageSource damageSource = damageRecord.source();
+        if (!damageSource.is(DamageTypeTags.IS_FALL) && !damageSource.is(DamageTypeTags.ALWAYS_MOST_SIGNIFICANT_FALL)) {
+            Component component = getDisplayName(attacker);
+            Entity entity = damageSource.getEntity();
+            Component component2 = getDisplayName(entity);
+            if (component2 != null && !component2.equals(component)) {
+                return this.getMessageForAssistedFall(entity, component2, "death.fell.assist.item", "death.fell.assist");
+            } else {
+                return (Component)(component != null ? this.getMessageForAssistedFall(attacker, component, "death.fell.finish.item", "death.fell.finish") : Component.translatable("death.fell.killer", this.mob.getDisplayName()));
+            }
+        } else {
+            FallLocation fallLocation = Objects.requireNonNullElse(damageRecord.fallLocation(), FallLocation.GENERIC);
+            return Component.translatable(fallLocation.languageKey(), this.mob.getDisplayName());
+        }
+    }
+
+    @Nullable
+    private static Component getDisplayName(@Nullable Entity entity) {
+        return entity == null ? null : entity.getDisplayName();
+    }
+
+    public Component getDeathMessage() {
+        if (this.entries.isEmpty()) {
+            return Component.translatable("death.attack.generic", this.mob.getDisplayName());
+        } else {
+            CombatEntry combatEntry = this.entries.get(this.entries.size() - 1);
+            DamageSource damageSource = combatEntry.source();
+            CombatEntry combatEntry2 = this.getMostSignificantFall();
+            DeathMessageType deathMessageType = damageSource.type().deathMessageType();
+            if (deathMessageType == DeathMessageType.FALL_VARIANTS && combatEntry2 != null) {
+                return this.getFallMessage(combatEntry2, damageSource.getEntity());
+            } else if (deathMessageType == DeathMessageType.INTENTIONAL_GAME_DESIGN) {
+                String string = "death.attack." + damageSource.getMsgId();
+                Component component = ComponentUtils.wrapInSquareBrackets(Component.translatable(string + ".link")).withStyle(INTENTIONAL_GAME_DESIGN_STYLE);
+                return Component.translatable(string + ".message", this.mob.getDisplayName(), component);
+            } else {
+                return damageSource.getLocalizedDeathMessage(this.mob);
+            }
+        }
+    }
+
+    @Nullable
+    private CombatEntry getMostSignificantFall() {
+        CombatEntry combatEntry = null;
+        CombatEntry combatEntry2 = null;
+        float f = 0.0F;
+        float g = 0.0F;
+
+        for(int i = 0; i < this.entries.size(); ++i) {
+            CombatEntry combatEntry3 = this.entries.get(i);
+            CombatEntry combatEntry4 = i > 0 ? this.entries.get(i - 1) : null;
+            DamageSource damageSource = combatEntry3.source();
+            boolean bl = damageSource.is(DamageTypeTags.ALWAYS_MOST_SIGNIFICANT_FALL);
+            float h = bl ? Float.MAX_VALUE : combatEntry3.fallDistance();
+            if ((damageSource.is(DamageTypeTags.IS_FALL) || bl) && h > 0.0F && (combatEntry == null || h > g)) {
+                if (i > 0) {
+                    combatEntry = combatEntry4;
+                } else {
+                    combatEntry = combatEntry3;
+                }
+
+                g = h;
+            }
+
+            if (combatEntry3.fallLocation() != null && (combatEntry2 == null || combatEntry3.damage() > f)) {
+                combatEntry2 = combatEntry3;
+                f = combatEntry3.damage();
+            }
+        }
+
+        if (g > 5.0F && combatEntry != null) {
+            return combatEntry;
+        } else {
+            return f > 5.0F && combatEntry2 != null ? combatEntry2 : null;
+        }
+    }
+
+    public int getCombatDuration() {
+        return this.inCombat ? this.mob.tickCount - this.combatStartTime : this.combatEndTime - this.combatStartTime;
+    }
+
+    public void recheckStatus() {
+        int i = this.inCombat ? 300 : 100;
+        if (this.takingDamage && (!this.mob.isAlive() || this.mob.tickCount - this.lastDamageTime > i)) {
+            boolean bl = this.inCombat;
+            this.takingDamage = false;
+            this.inCombat = false;
+            this.combatEndTime = this.mob.tickCount;
+            if (bl) {
+                this.mob.onLeaveCombat();
+            }
+
+            this.entries.clear();
+        }
+
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/ai/Brain.java b/src/main/java/net/minecraft/world/entity/ai/Brain.java
new file mode 100644
index 0000000000000000000000000000000000000000..ef6e968ed2708272eab407a983928382a2f2049c
--- /dev/null
+++ b/src/main/java/net/minecraft/world/entity/ai/Brain.java
@@ -0,0 +1,526 @@
+package net.minecraft.world.entity.ai;
+
+import com.google.common.annotations.VisibleForTesting;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
+import com.mojang.datafixers.util.Pair;
+import com.mojang.logging.LogUtils;
+import com.mojang.serialization.Codec;
+import com.mojang.serialization.DataResult;
+import com.mojang.serialization.Dynamic;
+import com.mojang.serialization.DynamicOps;
+import com.mojang.serialization.MapCodec;
+import com.mojang.serialization.MapLike;
+import com.mojang.serialization.RecordBuilder;
+import it.unimi.dsi.fastutil.objects.ObjectArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
+import java.util.Set;
+import java.util.function.Supplier;
+import java.util.stream.Stream;
+import javax.annotation.Nullable;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.util.VisibleForDebug;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.entity.ai.behavior.Behavior;
+import net.minecraft.world.entity.ai.behavior.BehaviorControl;
+import net.minecraft.world.entity.ai.memory.ExpirableValue;
+import net.minecraft.world.entity.ai.memory.MemoryModuleType;
+import net.minecraft.world.entity.ai.memory.MemoryStatus;
+import net.minecraft.world.entity.ai.sensing.Sensor;
+import net.minecraft.world.entity.ai.sensing.SensorType;
+import net.minecraft.world.entity.schedule.Activity;
+import net.minecraft.world.entity.schedule.Schedule;
+import org.apache.commons.lang3.mutable.MutableObject;
+import org.slf4j.Logger;
+
+public class Brain<E extends LivingEntity> {
+    static final Logger LOGGER = LogUtils.getLogger();
+    private final Supplier<Codec<Brain<E>>> codec;
+    private static final int SCHEDULE_UPDATE_DELAY = 20;
+    private final Map<MemoryModuleType<?>, Optional<? extends ExpirableValue<?>>> memories = Maps.newHashMap();
+    private final Map<SensorType<? extends Sensor<? super E>>, Sensor<? super E>> sensors = Maps.newLinkedHashMap();
+    private final Map<Integer, Map<Activity, Set<BehaviorControl<? super E>>>> availableBehaviorsByPriority = Maps.newTreeMap();
+    private Schedule schedule = Schedule.EMPTY;
+    private final Map<Activity, Set<Pair<MemoryModuleType<?>, MemoryStatus>>> activityRequirements = Maps.newHashMap();
+    private final Map<Activity, Set<MemoryModuleType<?>>> activityMemoriesToEraseWhenStopped = Maps.newHashMap();
+    private Set<Activity> coreActivities = Sets.newHashSet();
+    private final Set<Activity> activeActivities = Sets.newHashSet();
+    private Activity defaultActivity = Activity.IDLE;
+    private long lastScheduleUpdate = -9999L;
+
+    public static <E extends LivingEntity> Brain.Provider<E> provider(Collection<? extends MemoryModuleType<?>> memoryModules, Collection<? extends SensorType<? extends Sensor<? super E>>> sensors) {
+        return new Brain.Provider<>(memoryModules, sensors);
+    }
+
+    public static <E extends LivingEntity> Codec<Brain<E>> codec(final Collection<? extends MemoryModuleType<?>> memoryModules, final Collection<? extends SensorType<? extends Sensor<? super E>>> sensors) {
+        final MutableObject<Codec<Brain<E>>> mutableObject = new MutableObject<>();
+        mutableObject.setValue((new MapCodec<Brain<E>>() {
+            public <T> Stream<T> keys(DynamicOps<T> dynamicOps) {
+                return memoryModules.stream().flatMap((memoryType) -> {
+                    return memoryType.getCodec().map((codec) -> {
+                        return BuiltInRegistries.MEMORY_MODULE_TYPE.getKey(memoryType);
+                    }).stream();
+                }).map((id) -> {
+                    return dynamicOps.createString(id.toString());
+                });
+            }
+
+            public <T> DataResult<Brain<E>> decode(DynamicOps<T> dynamicOps, MapLike<T> mapLike) {
+                MutableObject<DataResult<ImmutableList.Builder<Brain.MemoryValue<?>>>> mutableObject = new MutableObject<>(DataResult.success(ImmutableList.builder()));
+                mapLike.entries().forEach((pair) -> {
+                    DataResult<MemoryModuleType<?>> dataResult = BuiltInRegistries.MEMORY_MODULE_TYPE.byNameCodec().parse(dynamicOps, pair.getFirst());
+                    DataResult<? extends Brain.MemoryValue<?>> dataResult2 = dataResult.flatMap((memoryType) -> {
+                        return this.captureRead(memoryType, dynamicOps, (T)pair.getSecond());
+                    });
+                    mutableObject.setValue(mutableObject.getValue().apply2(ImmutableList.Builder::add, dataResult2));
+                });
+                ImmutableList<Brain.MemoryValue<?>> immutableList = mutableObject.getValue().resultOrPartial(Brain.LOGGER::error).map(ImmutableList.Builder::build).orElseGet(ImmutableList::of);
+                return DataResult.success(new Brain<>(memoryModules, sensors, immutableList, mutableObject::getValue));
+            }
+
+            private <T, U> DataResult<Brain.MemoryValue<U>> captureRead(MemoryModuleType<U> memoryType, DynamicOps<T> ops, T value) {
+                return memoryType.getCodec().map(DataResult::success).orElseGet(() -> {
+                    return DataResult.error(() -> {
+                        return "No codec for memory: " + memoryType;
+                    });
+                }).flatMap((codec) -> {
+                    return codec.parse(ops, value);
+                }).map((data) -> {
+                    return new Brain.MemoryValue<>(memoryType, Optional.of(data));
+                });
+            }
+
+            public <T> RecordBuilder<T> encode(Brain<E> brain, DynamicOps<T> dynamicOps, RecordBuilder<T> recordBuilder) {
+                brain.memories().forEach((entry) -> {
+                    entry.serialize(dynamicOps, recordBuilder);
+                });
+                return recordBuilder;
+            }
+        }).fieldOf("memories").codec());
+        return mutableObject.getValue();
+    }
+
+    public Brain(Collection<? extends MemoryModuleType<?>> memories, Collection<? extends SensorType<? extends Sensor<? super E>>> sensors, ImmutableList<Brain.MemoryValue<?>> memoryEntries, Supplier<Codec<Brain<E>>> codecSupplier) {
+        this.codec = codecSupplier;
+
+        for(MemoryModuleType<?> memoryModuleType : memories) {
+            this.memories.put(memoryModuleType, Optional.empty());
+        }
+
+        for(SensorType<? extends Sensor<? super E>> sensorType : sensors) {
+            this.sensors.put(sensorType, sensorType.create());
+        }
+
+        for(Sensor<? super E> sensor : this.sensors.values()) {
+            for(MemoryModuleType<?> memoryModuleType2 : sensor.requires()) {
+                this.memories.put(memoryModuleType2, Optional.empty());
+            }
+        }
+
+        for(Brain.MemoryValue<?> memoryValue : memoryEntries) {
+            memoryValue.setMemoryInternal(this);
+        }
+
+    }
+
+    public <T> DataResult<T> serializeStart(DynamicOps<T> ops) {
+        return this.codec.get().encodeStart(ops, this);
+    }
+
+    Stream<Brain.MemoryValue<?>> memories() {
+        return this.memories.entrySet().stream().map((entry) -> {
+            return Brain.MemoryValue.createUnchecked(entry.getKey(), entry.getValue());
+        });
+    }
+
+    public boolean hasMemoryValue(MemoryModuleType<?> type) {
+        return this.checkMemory(type, MemoryStatus.VALUE_PRESENT);
+    }
+
+    public void clearMemories() {
+        this.memories.keySet().forEach((type) -> {
+            this.memories.put(type, Optional.empty());
+        });
+    }
+
+    public <U> void eraseMemory(MemoryModuleType<U> type) {
+        this.setMemory(type, Optional.empty());
+    }
+
+    public <U> void setMemory(MemoryModuleType<U> type, @Nullable U value) {
+        this.setMemory(type, Optional.ofNullable(value));
+    }
+
+    public <U> void setMemoryWithExpiry(MemoryModuleType<U> type, U value, long expiry) {
+        this.setMemoryInternal(type, Optional.of(ExpirableValue.of(value, expiry)));
+    }
+
+    public <U> void setMemory(MemoryModuleType<U> type, Optional<? extends U> value) {
+        this.setMemoryInternal(type, value.map(ExpirableValue::of));
+    }
+
+    <U> void setMemoryInternal(MemoryModuleType<U> type, Optional<? extends ExpirableValue<?>> memory) {
+        if (this.memories.containsKey(type)) {
+            if (memory.isPresent() && this.isEmptyCollection(memory.get().getValue())) {
+                this.eraseMemory(type);
+            } else {
+                this.memories.put(type, memory);
+            }
+        }
+
+    }
+
+    public <U> Optional<U> getMemory(MemoryModuleType<U> type) {
+        Optional<? extends ExpirableValue<?>> optional = this.memories.get(type);
+        if (optional == null) {
+            throw new IllegalStateException("Unregistered memory fetched: " + type);
+        } else {
+            return optional.map(ExpirableValue::getValue);
+        }
+    }
+
+    @Nullable
+    public <U> Optional<U> getMemoryInternal(MemoryModuleType<U> type) {
+        Optional<? extends ExpirableValue<?>> optional = this.memories.get(type);
+        return optional == null ? null : optional.map(ExpirableValue::getValue);
+    }
+
+    public <U> long getTimeUntilExpiry(MemoryModuleType<U> type) {
+        Optional<? extends ExpirableValue<?>> optional = this.memories.get(type);
+        return optional.map(ExpirableValue::getTimeToLive).orElse(0L);
+    }
+
+    /** @deprecated */
+    @Deprecated
+    @VisibleForDebug
+    public Map<MemoryModuleType<?>, Optional<? extends ExpirableValue<?>>> getMemories() {
+        return this.memories;
+    }
+
+    public <U> boolean isMemoryValue(MemoryModuleType<U> type, U value) {
+        return !this.hasMemoryValue(type) ? false : this.getMemory(type).filter((memoryValue) -> {
+            return memoryValue.equals(value);
+        }).isPresent();
+    }
+
+    public boolean checkMemory(MemoryModuleType<?> type, MemoryStatus state) {
+        Optional<? extends ExpirableValue<?>> optional = this.memories.get(type);
+        if (optional == null) {
+            return false;
+        } else {
+            return state == MemoryStatus.REGISTERED || state == MemoryStatus.VALUE_PRESENT && optional.isPresent() || state == MemoryStatus.VALUE_ABSENT && !optional.isPresent();
+        }
+    }
+
+    public Schedule getSchedule() {
+        return this.schedule;
+    }
+
+    public void setSchedule(Schedule schedule) {
+        this.schedule = schedule;
+    }
+
+    public void setCoreActivities(Set<Activity> coreActivities) {
+        this.coreActivities = coreActivities;
+    }
+
+    /** @deprecated */
+    @Deprecated
+    @VisibleForDebug
+    public Set<Activity> getActiveActivities() {
+        return this.activeActivities;
+    }
+
+    /** @deprecated */
+    @Deprecated
+    @VisibleForDebug
+    public List<BehaviorControl<? super E>> getRunningBehaviors() {
+        List<BehaviorControl<? super E>> list = new ObjectArrayList<>();
+
+        for(Map<Activity, Set<BehaviorControl<? super E>>> map : this.availableBehaviorsByPriority.values()) {
+            for(Set<BehaviorControl<? super E>> set : map.values()) {
+                for(BehaviorControl<? super E> behaviorControl : set) {
+                    if (behaviorControl.getStatus() == Behavior.Status.RUNNING) {
+                        list.add(behaviorControl);
+                    }
+                }
+            }
+        }
+
+        return list;
+    }
+
+    public void useDefaultActivity() {
+        this.setActiveActivity(this.defaultActivity);
+    }
+
+    public Optional<Activity> getActiveNonCoreActivity() {
+        for(Activity activity : this.activeActivities) {
+            if (!this.coreActivities.contains(activity)) {
+                return Optional.of(activity);
+            }
+        }
+
+        return Optional.empty();
+    }
+
+    public void setActiveActivityIfPossible(Activity activity) {
+        if (this.activityRequirementsAreMet(activity)) {
+            this.setActiveActivity(activity);
+        } else {
+            this.useDefaultActivity();
+        }
+
+    }
+
+    private void setActiveActivity(Activity except) {
+        if (!this.isActive(except)) {
+            this.eraseMemoriesForOtherActivitesThan(except);
+            this.activeActivities.clear();
+            this.activeActivities.addAll(this.coreActivities);
+            this.activeActivities.add(except);
+        }
+    }
+
+    private void eraseMemoriesForOtherActivitesThan(Activity except) {
+        for(Activity activity : this.activeActivities) {
+            if (activity != except) {
+                Set<MemoryModuleType<?>> set = this.activityMemoriesToEraseWhenStopped.get(activity);
+                if (set != null) {
+                    for(MemoryModuleType<?> memoryModuleType : set) {
+                        this.eraseMemory(memoryModuleType);
+                    }
+                }
+            }
+        }
+
+    }
+
+    public void updateActivityFromSchedule(long timeOfDay, long time) {
+        if (time - this.lastScheduleUpdate > 20L) {
+            this.lastScheduleUpdate = time;
+            Activity activity = this.getSchedule().getActivityAt((int)(timeOfDay % 24000L));
+            if (!this.activeActivities.contains(activity)) {
+                this.setActiveActivityIfPossible(activity);
+            }
+        }
+
+    }
+
+    public void setActiveActivityToFirstValid(List<Activity> activities) {
+        for(Activity activity : activities) {
+            if (this.activityRequirementsAreMet(activity)) {
+                this.setActiveActivity(activity);
+                break;
+            }
+        }
+
+    }
+
+    public void setDefaultActivity(Activity activity) {
+        this.defaultActivity = activity;
+    }
+
+    public void addActivity(Activity activity, int begin, ImmutableList<? extends BehaviorControl<? super E>> list) {
+        this.addActivity(activity, this.createPriorityPairs(begin, list));
+    }
+
+    public void addActivityAndRemoveMemoryWhenStopped(Activity activity, int begin, ImmutableList<? extends BehaviorControl<? super E>> tasks, MemoryModuleType<?> memoryType) {
+        Set<Pair<MemoryModuleType<?>, MemoryStatus>> set = ImmutableSet.of(Pair.of(memoryType, MemoryStatus.VALUE_PRESENT));
+        Set<MemoryModuleType<?>> set2 = ImmutableSet.of(memoryType);
+        this.addActivityAndRemoveMemoriesWhenStopped(activity, this.createPriorityPairs(begin, tasks), set, set2);
+    }
+
+    public void addActivity(Activity activity, ImmutableList<? extends Pair<Integer, ? extends BehaviorControl<? super E>>> indexedTasks) {
+        this.addActivityAndRemoveMemoriesWhenStopped(activity, indexedTasks, ImmutableSet.of(), Sets.newHashSet());
+    }
+
+    public void addActivityWithConditions(Activity activity, ImmutableList<? extends Pair<Integer, ? extends BehaviorControl<? super E>>> indexedTasks, Set<Pair<MemoryModuleType<?>, MemoryStatus>> requiredMemories) {
+        this.addActivityAndRemoveMemoriesWhenStopped(activity, indexedTasks, requiredMemories, Sets.newHashSet());
+    }
+
+    public void addActivityAndRemoveMemoriesWhenStopped(Activity activity, ImmutableList<? extends Pair<Integer, ? extends BehaviorControl<? super E>>> indexedTasks, Set<Pair<MemoryModuleType<?>, MemoryStatus>> requiredMemories, Set<MemoryModuleType<?>> forgettingMemories) {
+        this.activityRequirements.put(activity, requiredMemories);
+        if (!forgettingMemories.isEmpty()) {
+            this.activityMemoriesToEraseWhenStopped.put(activity, forgettingMemories);
+        }
+
+        for(Pair<Integer, ? extends BehaviorControl<? super E>> pair : indexedTasks) {
+            this.availableBehaviorsByPriority.computeIfAbsent(pair.getFirst(), (index) -> {
+                return Maps.newHashMap();
+            }).computeIfAbsent(activity, (activity2) -> {
+                return Sets.newLinkedHashSet();
+            }).add(pair.getSecond());
+        }
+
+    }
+
+    @VisibleForTesting
+    public void removeAllBehaviors() {
+        this.availableBehaviorsByPriority.clear();
+    }
+
+    public boolean isActive(Activity activity) {
+        return this.activeActivities.contains(activity);
+    }
+
+    public Brain<E> copyWithoutBehaviors() {
+        Brain<E> brain = new Brain<>(this.memories.keySet(), this.sensors.keySet(), ImmutableList.of(), this.codec);
+
+        for(Map.Entry<MemoryModuleType<?>, Optional<? extends ExpirableValue<?>>> entry : this.memories.entrySet()) {
+            MemoryModuleType<?> memoryModuleType = entry.getKey();
+            if (entry.getValue().isPresent()) {
+                brain.memories.put(memoryModuleType, entry.getValue());
+            }
+        }
+
+        return brain;
+    }
+
+    public void tick(ServerLevel world, E entity) {
+        this.forgetOutdatedMemories();
+        this.tickSensors(world, entity);
+        this.startEachNonRunningBehavior(world, entity);
+        this.tickEachRunningBehavior(world, entity);
+    }
+
+    private void tickSensors(ServerLevel world, E entity) {
+        for(Sensor<? super E> sensor : this.sensors.values()) {
+            sensor.tick(world, entity);
+        }
+
+    }
+
+    private void forgetOutdatedMemories() {
+        for(Map.Entry<MemoryModuleType<?>, Optional<? extends ExpirableValue<?>>> entry : this.memories.entrySet()) {
+            if (entry.getValue().isPresent()) {
+                ExpirableValue<?> expirableValue = entry.getValue().get();
+                if (expirableValue.hasExpired()) {
+                    this.eraseMemory(entry.getKey());
+                }
+
+                expirableValue.tick();
+            }
+        }
+
+    }
+
+    public void stopAll(ServerLevel world, E entity) {
+        long l = entity.level().getGameTime();
+
+        for(BehaviorControl<? super E> behaviorControl : this.getRunningBehaviors()) {
+            behaviorControl.doStop(world, entity, l);
+        }
+
+    }
+
+    private void startEachNonRunningBehavior(ServerLevel world, E entity) {
+        long l = world.getGameTime();
+
+        for(Map<Activity, Set<BehaviorControl<? super E>>> map : this.availableBehaviorsByPriority.values()) {
+            for(Map.Entry<Activity, Set<BehaviorControl<? super E>>> entry : map.entrySet()) {
+                Activity activity = entry.getKey();
+                if (this.activeActivities.contains(activity)) {
+                    for(BehaviorControl<? super E> behaviorControl : entry.getValue()) {
+                        if (behaviorControl.getStatus() == Behavior.Status.STOPPED) {
+                            behaviorControl.tryStart(world, entity, l);
+                        }
+                    }
+                }
+            }
+        }
+
+    }
+
+    private void tickEachRunningBehavior(ServerLevel world, E entity) {
+        long l = world.getGameTime();
+
+        for(BehaviorControl<? super E> behaviorControl : this.getRunningBehaviors()) {
+            behaviorControl.tickOrStop(world, entity, l);
+        }
+
+    }
+
+    private boolean activityRequirementsAreMet(Activity activity) {
+        if (!this.activityRequirements.containsKey(activity)) {
+            return false;
+        } else {
+            for(Pair<MemoryModuleType<?>, MemoryStatus> pair : this.activityRequirements.get(activity)) {
+                MemoryModuleType<?> memoryModuleType = pair.getFirst();
+                MemoryStatus memoryStatus = pair.getSecond();
+                if (!this.checkMemory(memoryModuleType, memoryStatus)) {
+                    return false;
+                }
+            }
+
+            return true;
+        }
+    }
+
+    private boolean isEmptyCollection(Object value) {
+        return value instanceof Collection && ((Collection)value).isEmpty();
+    }
+
+    ImmutableList<? extends Pair<Integer, ? extends BehaviorControl<? super E>>> createPriorityPairs(int begin, ImmutableList<? extends BehaviorControl<? super E>> tasks) {
+        int i = begin;
+        ImmutableList.Builder<Pair<Integer, ? extends BehaviorControl<? super E>>> builder = ImmutableList.builder();
+
+        for(BehaviorControl<? super E> behaviorControl : tasks) {
+            builder.add(Pair.of(i++, behaviorControl));
+        }
+
+        return builder.build();
+    }
+
+    static final class MemoryValue<U> {
+        private final MemoryModuleType<U> type;
+        private final Optional<? extends ExpirableValue<U>> value;
+
+        static <U> Brain.MemoryValue<U> createUnchecked(MemoryModuleType<U> type, Optional<? extends ExpirableValue<?>> data) {
+            return new Brain.MemoryValue<>(type, data);
+        }
+
+        MemoryValue(MemoryModuleType<U> type, Optional<? extends ExpirableValue<U>> data) {
+            this.type = type;
+            this.value = data;
+        }
+
+        void setMemoryInternal(Brain<?> brain) {
+            brain.setMemoryInternal(this.type, this.value);
+        }
+
+        public <T> void serialize(DynamicOps<T> ops, RecordBuilder<T> builder) {
+            this.type.getCodec().ifPresent((codec) -> {
+                this.value.ifPresent((data) -> {
+                    builder.add(BuiltInRegistries.MEMORY_MODULE_TYPE.byNameCodec().encodeStart(ops, this.type), codec.encodeStart(ops, data));
+                });
+            });
+        }
+    }
+
+    public static final class Provider<E extends LivingEntity> {
+        private final Collection<? extends MemoryModuleType<?>> memoryTypes;
+        private final Collection<? extends SensorType<? extends Sensor<? super E>>> sensorTypes;
+        private final Codec<Brain<E>> codec;
+
+        Provider(Collection<? extends MemoryModuleType<?>> memoryModules, Collection<? extends SensorType<? extends Sensor<? super E>>> sensors) {
+            this.memoryTypes = memoryModules;
+            this.sensorTypes = sensors;
+            this.codec = Brain.codec(memoryModules, sensors);
+        }
+
+        public Brain<E> makeBrain(Dynamic<?> data) {
+            return this.codec.parse(data).resultOrPartial(Brain.LOGGER::error).orElseGet(() -> {
+                return new Brain<>(this.memoryTypes, this.sensorTypes, ImmutableList.of(), () -> {
+                    return this.codec;
+                });
+            });
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/ai/behavior/PoiCompetitorScan.java b/src/main/java/net/minecraft/world/entity/ai/behavior/PoiCompetitorScan.java
new file mode 100644
index 0000000000000000000000000000000000000000..8ec07578c1e41997a2e5ef158885ad3f4c2a31b6
--- /dev/null
+++ b/src/main/java/net/minecraft/world/entity/ai/behavior/PoiCompetitorScan.java
@@ -0,0 +1,58 @@
+package net.minecraft.world.entity.ai.behavior;
+
+import java.util.List;
+import java.util.Optional;
+import net.minecraft.core.GlobalPos;
+import net.minecraft.core.Holder;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.entity.ai.behavior.declarative.BehaviorBuilder;
+import net.minecraft.world.entity.ai.memory.MemoryModuleType;
+import net.minecraft.world.entity.ai.village.poi.PoiType;
+import net.minecraft.world.entity.npc.Villager;
+import net.minecraft.world.entity.npc.VillagerProfession;
+
+public class PoiCompetitorScan {
+    public static BehaviorControl<Villager> create() {
+        return BehaviorBuilder.create((context) -> {
+            return context.group(context.present(MemoryModuleType.JOB_SITE), context.present(MemoryModuleType.NEAREST_LIVING_ENTITIES)).apply(context, (jobSite, mobs) -> {
+                return (world, entity, time) -> {
+                    GlobalPos globalPos = context.get(jobSite);
+                    world.getPoiManager().getType(globalPos.pos()).ifPresent((poiType) -> {
+                        context.<List<LivingEntity>>get(mobs).stream().filter((mob) -> {
+                            return mob instanceof Villager && mob != entity;
+                        }).map((villager) -> {
+                            return (Villager)villager;
+                        }).filter(LivingEntity::isAlive).filter((villager) -> {
+                            return competesForSameJobsite(globalPos, poiType, villager);
+                        }).reduce(entity, PoiCompetitorScan::selectWinner);
+                    });
+                    return true;
+                };
+            });
+        });
+    }
+
+    private static Villager selectWinner(Villager first, Villager second) {
+        Villager villager;
+        Villager villager2;
+        if (first.getVillagerXp() > second.getVillagerXp()) {
+            villager = first;
+            villager2 = second;
+        } else {
+            villager = second;
+            villager2 = first;
+        }
+
+        villager2.getBrain().eraseMemory(MemoryModuleType.JOB_SITE);
+        return villager;
+    }
+
+    private static boolean competesForSameJobsite(GlobalPos pos, Holder<PoiType> poiType, Villager villager) {
+        Optional<GlobalPos> optional = villager.getBrain().getMemory(MemoryModuleType.JOB_SITE);
+        return optional.isPresent() && pos.equals(optional.get()) && hasMatchingProfession(poiType, villager.getVillagerData().getProfession());
+    }
+
+    private static boolean hasMatchingProfession(Holder<PoiType> poiType, VillagerProfession profession) {
+        return profession.heldJobSite().test(poiType);
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/block/entity/TickingBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/TickingBlockEntity.java
new file mode 100644
index 0000000000000000000000000000000000000000..28e3b73507b988f7234cbf29c4024c88180d0aef
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/block/entity/TickingBlockEntity.java
@@ -0,0 +1,13 @@
+package net.minecraft.world.level.block.entity;
+
+import net.minecraft.core.BlockPos;
+
+public interface TickingBlockEntity {
+    void tick();
+
+    boolean isRemoved();
+
+    BlockPos getPos();
+
+    String getType();
+}
diff --git a/src/main/java/net/minecraft/world/level/levelgen/structure/StructureStart.java b/src/main/java/net/minecraft/world/level/levelgen/structure/StructureStart.java
new file mode 100644
index 0000000000000000000000000000000000000000..6570e0b61d7602c57c61398ddce50418d0719ff2
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/levelgen/structure/StructureStart.java
@@ -0,0 +1,144 @@
+package net.minecraft.world.level.levelgen.structure;
+
+import com.mojang.logging.LogUtils;
+import java.util.List;
+import javax.annotation.Nullable;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Registry;
+import net.minecraft.core.registries.Registries;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.ListTag;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.util.RandomSource;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.StructureManager;
+import net.minecraft.world.level.WorldGenLevel;
+import net.minecraft.world.level.chunk.ChunkGenerator;
+import net.minecraft.world.level.levelgen.structure.pieces.PiecesContainer;
+import net.minecraft.world.level.levelgen.structure.pieces.StructurePieceSerializationContext;
+import net.minecraft.world.level.levelgen.structure.structures.OceanMonumentStructure;
+import org.slf4j.Logger;
+
+public final class StructureStart {
+    public static final String INVALID_START_ID = "INVALID";
+    public static final StructureStart INVALID_START = new StructureStart((Structure)null, new ChunkPos(0, 0), 0, new PiecesContainer(List.of()));
+    private static final Logger LOGGER = LogUtils.getLogger();
+    private final Structure structure;
+    private final PiecesContainer pieceContainer;
+    private final ChunkPos chunkPos;
+    private int references;
+    @Nullable
+    private volatile BoundingBox cachedBoundingBox;
+
+    public StructureStart(Structure structure, ChunkPos pos, int references, PiecesContainer children) {
+        this.structure = structure;
+        this.chunkPos = pos;
+        this.references = references;
+        this.pieceContainer = children;
+    }
+
+    @Nullable
+    public static StructureStart loadStaticStart(StructurePieceSerializationContext context, CompoundTag nbt, long seed) {
+        String string = nbt.getString("id");
+        if ("INVALID".equals(string)) {
+            return INVALID_START;
+        } else {
+            Registry<Structure> registry = context.registryAccess().registryOrThrow(Registries.STRUCTURE);
+            Structure structure = registry.get(new ResourceLocation(string));
+            if (structure == null) {
+                LOGGER.error("Unknown stucture id: {}", (Object)string);
+                return null;
+            } else {
+                ChunkPos chunkPos = new ChunkPos(nbt.getInt("ChunkX"), nbt.getInt("ChunkZ"));
+                int i = nbt.getInt("references");
+                ListTag listTag = nbt.getList("Children", 10);
+
+                try {
+                    PiecesContainer piecesContainer = PiecesContainer.load(listTag, context);
+                    if (structure instanceof OceanMonumentStructure) {
+                        piecesContainer = OceanMonumentStructure.regeneratePiecesAfterLoad(chunkPos, seed, piecesContainer);
+                    }
+
+                    return new StructureStart(structure, chunkPos, i, piecesContainer);
+                } catch (Exception var11) {
+                    LOGGER.error("Failed Start with id {}", string, var11);
+                    return null;
+                }
+            }
+        }
+    }
+
+    public BoundingBox getBoundingBox() {
+        BoundingBox boundingBox = this.cachedBoundingBox;
+        if (boundingBox == null) {
+            boundingBox = this.structure.adjustBoundingBox(this.pieceContainer.calculateBoundingBox());
+            this.cachedBoundingBox = boundingBox;
+        }
+
+        return boundingBox;
+    }
+
+    public void placeInChunk(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos) {
+        List<StructurePiece> list = this.pieceContainer.pieces();
+        if (!list.isEmpty()) {
+            BoundingBox boundingBox = (list.get(0)).boundingBox;
+            BlockPos blockPos = boundingBox.getCenter();
+            BlockPos blockPos2 = new BlockPos(blockPos.getX(), boundingBox.minY(), blockPos.getZ());
+
+            for(StructurePiece structurePiece : list) {
+                if (structurePiece.getBoundingBox().intersects(chunkBox)) {
+                    structurePiece.postProcess(world, structureAccessor, chunkGenerator, random, chunkBox, chunkPos, blockPos2);
+                }
+            }
+
+            this.structure.afterPlace(world, structureAccessor, chunkGenerator, random, chunkBox, chunkPos, this.pieceContainer);
+        }
+    }
+
+    public CompoundTag createTag(StructurePieceSerializationContext context, ChunkPos chunkPos) {
+        CompoundTag compoundTag = new CompoundTag();
+        if (this.isValid()) {
+            compoundTag.putString("id", context.registryAccess().registryOrThrow(Registries.STRUCTURE).getKey(this.structure).toString());
+            compoundTag.putInt("ChunkX", chunkPos.x);
+            compoundTag.putInt("ChunkZ", chunkPos.z);
+            compoundTag.putInt("references", this.references);
+            compoundTag.put("Children", this.pieceContainer.save(context));
+            return compoundTag;
+        } else {
+            compoundTag.putString("id", "INVALID");
+            return compoundTag;
+        }
+    }
+
+    public boolean isValid() {
+        return !this.pieceContainer.isEmpty();
+    }
+
+    public ChunkPos getChunkPos() {
+        return this.chunkPos;
+    }
+
+    public boolean canBeReferenced() {
+        return this.references < this.getMaxReferences();
+    }
+
+    public void addReference() {
+        ++this.references;
+    }
+
+    public int getReferences() {
+        return this.references;
+    }
+
+    protected int getMaxReferences() {
+        return 1;
+    }
+
+    public Structure getStructure() {
+        return this.structure;
+    }
+
+    public List<StructurePiece> getPieces() {
+        return this.pieceContainer.pieces();
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/saveddata/SavedData.java b/src/main/java/net/minecraft/world/level/saveddata/SavedData.java
new file mode 100644
index 0000000000000000000000000000000000000000..353e602d476beea23e591ad770227c5d6c1e97fa
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/saveddata/SavedData.java
@@ -0,0 +1,44 @@
+package net.minecraft.world.level.saveddata;
+
+import com.mojang.logging.LogUtils;
+import java.io.File;
+import java.io.IOException;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.NbtIo;
+import net.minecraft.nbt.NbtUtils;
+import org.slf4j.Logger;
+
+public abstract class SavedData {
+    private static final Logger LOGGER = LogUtils.getLogger();
+    private boolean dirty;
+
+    public abstract CompoundTag save(CompoundTag nbt);
+
+    public void setDirty() {
+        this.setDirty(true);
+    }
+
+    public void setDirty(boolean dirty) {
+        this.dirty = dirty;
+    }
+
+    public boolean isDirty() {
+        return this.dirty;
+    }
+
+    public void save(File file) {
+        if (this.isDirty()) {
+            CompoundTag compoundTag = new CompoundTag();
+            compoundTag.put("data", this.save(new CompoundTag()));
+            NbtUtils.addCurrentDataVersion(compoundTag);
+
+            try {
+                NbtIo.writeCompressed(compoundTag, file);
+            } catch (IOException var4) {
+                LOGGER.error("Could not save data {}", this, var4);
+            }
+
+            this.setDirty(false);
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/saveddata/maps/MapIndex.java b/src/main/java/net/minecraft/world/level/saveddata/maps/MapIndex.java
new file mode 100644
index 0000000000000000000000000000000000000000..9b2948b5150c8f039ca667a50765109721b93947
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/saveddata/maps/MapIndex.java
@@ -0,0 +1,43 @@
+package net.minecraft.world.level.saveddata.maps;
+
+import it.unimi.dsi.fastutil.objects.Object2IntMap;
+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.world.level.saveddata.SavedData;
+
+public class MapIndex extends SavedData {
+    public static final String FILE_NAME = "idcounts";
+    private final Object2IntMap<String> usedAuxIds = new Object2IntOpenHashMap<>();
+
+    public MapIndex() {
+        this.usedAuxIds.defaultReturnValue(-1);
+    }
+
+    public static MapIndex load(CompoundTag nbt) {
+        MapIndex mapIndex = new MapIndex();
+
+        for(String string : nbt.getAllKeys()) {
+            if (nbt.contains(string, 99)) {
+                mapIndex.usedAuxIds.put(string, nbt.getInt(string));
+            }
+        }
+
+        return mapIndex;
+    }
+
+    @Override
+    public CompoundTag save(CompoundTag nbt) {
+        for(Object2IntMap.Entry<String> entry : this.usedAuxIds.object2IntEntrySet()) {
+            nbt.putInt(entry.getKey(), entry.getIntValue());
+        }
+
+        return nbt;
+    }
+
+    public int getFreeAuxValueForMap() {
+        int i = this.usedAuxIds.getInt("map") + 1;
+        this.usedAuxIds.put("map", i);
+        this.setDirty();
+        return i;
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/storage/DimensionDataStorage.java b/src/main/java/net/minecraft/world/level/storage/DimensionDataStorage.java
new file mode 100644
index 0000000000000000000000000000000000000000..defe31a5d3aa89a3d18b94f2ff005594e38754b3
--- /dev/null
+++ b/src/main/java/net/minecraft/world/level/storage/DimensionDataStorage.java
@@ -0,0 +1,129 @@
+package net.minecraft.world.level.storage;
+
+import com.google.common.collect.Maps;
+import com.mojang.datafixers.DataFixer;
+import com.mojang.logging.LogUtils;
+import java.io.DataInputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.PushbackInputStream;
+import java.util.Map;
+import java.util.function.Function;
+import java.util.function.Supplier;
+import javax.annotation.Nullable;
+import net.minecraft.SharedConstants;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.NbtIo;
+import net.minecraft.nbt.NbtUtils;
+import net.minecraft.util.datafix.DataFixTypes;
+import net.minecraft.world.level.saveddata.SavedData;
+import org.slf4j.Logger;
+
+public class DimensionDataStorage {
+    private static final Logger LOGGER = LogUtils.getLogger();
+    public final Map<String, SavedData> cache = Maps.newHashMap();
+    private final DataFixer fixerUpper;
+    private final File dataFolder;
+
+    public DimensionDataStorage(File directory, DataFixer dataFixer) {
+        this.fixerUpper = dataFixer;
+        this.dataFolder = directory;
+    }
+
+    private File getDataFile(String id) {
+        return new File(this.dataFolder, id + ".dat");
+    }
+
+    public <T extends SavedData> T computeIfAbsent(Function<CompoundTag, T> readFunction, Supplier<T> supplier, String id) {
+        T savedData = this.get(readFunction, id);
+        if (savedData != null) {
+            return savedData;
+        } else {
+            T savedData2 = supplier.get();
+            this.set(id, savedData2);
+            return savedData2;
+        }
+    }
+
+    @Nullable
+    public <T extends SavedData> T get(Function<CompoundTag, T> readFunction, String id) {
+        SavedData savedData = this.cache.get(id);
+        if (savedData == null && !this.cache.containsKey(id)) {
+            savedData = this.readSavedData(readFunction, id);
+            this.cache.put(id, savedData);
+        }
+
+        return (T)savedData;
+    }
+
+    @Nullable
+    private <T extends SavedData> T readSavedData(Function<CompoundTag, T> readFunction, String id) {
+        try {
+            File file = this.getDataFile(id);
+            if (file.exists()) {
+                CompoundTag compoundTag = this.readTagFromDisk(id, SharedConstants.getCurrentVersion().getDataVersion().getVersion());
+                return readFunction.apply(compoundTag.getCompound("data"));
+            }
+        } catch (Exception var5) {
+            LOGGER.error("Error loading saved data: {}", id, var5);
+        }
+
+        return (T)null;
+    }
+
+    public void set(String id, SavedData state) {
+        this.cache.put(id, state);
+    }
+
+    public CompoundTag readTagFromDisk(String id, int dataVersion) throws IOException {
+        File file = this.getDataFile(id);
+
+        CompoundTag var8;
+        try (
+            FileInputStream fileInputStream = new FileInputStream(file);
+            PushbackInputStream pushbackInputStream = new PushbackInputStream(fileInputStream, 2);
+        ) {
+            CompoundTag compoundTag;
+            if (this.isGzip(pushbackInputStream)) {
+                compoundTag = NbtIo.readCompressed(pushbackInputStream);
+            } else {
+                try (DataInputStream dataInputStream = new DataInputStream(pushbackInputStream)) {
+                    compoundTag = NbtIo.read(dataInputStream);
+                }
+            }
+
+            int i = NbtUtils.getDataVersion(compoundTag, 1343);
+            var8 = DataFixTypes.SAVED_DATA.update(this.fixerUpper, compoundTag, i, dataVersion);
+        }
+
+        return var8;
+    }
+
+    private boolean isGzip(PushbackInputStream stream) throws IOException {
+        byte[] bs = new byte[2];
+        boolean bl = false;
+        int i = stream.read(bs, 0, 2);
+        if (i == 2) {
+            int j = (bs[1] & 255) << 8 | bs[0] & 255;
+            if (j == 35615) {
+                bl = true;
+            }
+        }
+
+        if (i != 0) {
+            stream.unread(bs, 0, i);
+        }
+
+        return bl;
+    }
+
+    public void save() {
+        this.cache.forEach((id, state) -> {
+            if (state != null) {
+                state.save(this.getDataFile(id));
+            }
+
+        });
+    }
+}
diff --git a/src/main/java/net/minecraft/world/ticks/LevelTicks.java b/src/main/java/net/minecraft/world/ticks/LevelTicks.java
new file mode 100644
index 0000000000000000000000000000000000000000..1d7c663fa0e550bd0cfb9a4b83ccd7e2968666f0
--- /dev/null
+++ b/src/main/java/net/minecraft/world/ticks/LevelTicks.java
@@ -0,0 +1,298 @@
+package net.minecraft.world.ticks;
+
+import it.unimi.dsi.fastutil.longs.Long2LongMap;
+import it.unimi.dsi.fastutil.longs.Long2LongMaps;
+import it.unimi.dsi.fastutil.longs.Long2LongOpenHashMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.objects.ObjectIterator;
+import it.unimi.dsi.fastutil.objects.ObjectOpenCustomHashSet;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Comparator;
+import java.util.List;
+import java.util.LongSummaryStatistics;
+import java.util.PriorityQueue;
+import java.util.Queue;
+import java.util.Set;
+import java.util.function.BiConsumer;
+import java.util.function.LongPredicate;
+import java.util.function.Predicate;
+import java.util.function.Supplier;
+import net.minecraft.Util;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.SectionPos;
+import net.minecraft.core.Vec3i;
+import net.minecraft.util.profiling.ProfilerFiller;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.levelgen.structure.BoundingBox;
+
+public class LevelTicks<T> implements LevelTickAccess<T> {
+    private static final Comparator<LevelChunkTicks<?>> CONTAINER_DRAIN_ORDER = (a, b) -> {
+        return ScheduledTick.INTRA_TICK_DRAIN_ORDER.compare(a.peek(), b.peek());
+    };
+    private final LongPredicate tickCheck;
+    private final Supplier<ProfilerFiller> profiler;
+    private final Long2ObjectMap<LevelChunkTicks<T>> allContainers = new Long2ObjectOpenHashMap<>();
+    private final Long2LongMap nextTickForContainer = Util.make(new Long2LongOpenHashMap(), (map) -> {
+        map.defaultReturnValue(Long.MAX_VALUE);
+    });
+    private final Queue<LevelChunkTicks<T>> containersToTick = new PriorityQueue<>(CONTAINER_DRAIN_ORDER);
+    private final Queue<ScheduledTick<T>> toRunThisTick = new ArrayDeque<>();
+    private final List<ScheduledTick<T>> alreadyRunThisTick = new ArrayList<>();
+    private final Set<ScheduledTick<?>> toRunThisTickSet = new ObjectOpenCustomHashSet<>(ScheduledTick.UNIQUE_TICK_HASH);
+    private final BiConsumer<LevelChunkTicks<T>, ScheduledTick<T>> chunkScheduleUpdater = (chunkTickScheduler, tick) -> {
+        if (tick.equals(chunkTickScheduler.peek())) {
+            this.updateContainerScheduling(tick);
+        }
+
+    };
+
+    public LevelTicks(LongPredicate tickingFutureReadyPredicate, Supplier<ProfilerFiller> profilerGetter) {
+        this.tickCheck = tickingFutureReadyPredicate;
+        this.profiler = profilerGetter;
+    }
+
+    public void addContainer(ChunkPos pos, LevelChunkTicks<T> scheduler) {
+        long l = pos.toLong();
+        this.allContainers.put(l, scheduler);
+        ScheduledTick<T> scheduledTick = scheduler.peek();
+        if (scheduledTick != null) {
+            this.nextTickForContainer.put(l, scheduledTick.triggerTick());
+        }
+
+        scheduler.setOnTickAdded(this.chunkScheduleUpdater);
+    }
+
+    public void removeContainer(ChunkPos pos) {
+        long l = pos.toLong();
+        LevelChunkTicks<T> levelChunkTicks = this.allContainers.remove(l);
+        this.nextTickForContainer.remove(l);
+        if (levelChunkTicks != null) {
+            levelChunkTicks.setOnTickAdded((BiConsumer<LevelChunkTicks<T>, ScheduledTick<T>>)null);
+        }
+
+    }
+
+    @Override
+    public void schedule(ScheduledTick<T> orderedTick) {
+        long l = ChunkPos.asLong(orderedTick.pos());
+        LevelChunkTicks<T> levelChunkTicks = this.allContainers.get(l);
+        if (levelChunkTicks == null) {
+            Util.pauseInIde(new IllegalStateException("Trying to schedule tick in not loaded position " + orderedTick.pos()));
+        } else {
+            levelChunkTicks.schedule(orderedTick);
+        }
+    }
+
+    public void tick(long time, int maxTicks, BiConsumer<BlockPos, T> ticker) {
+        ProfilerFiller profilerFiller = this.profiler.get();
+        profilerFiller.push("collect");
+        this.collectTicks(time, maxTicks, profilerFiller);
+        profilerFiller.popPush("run");
+        profilerFiller.incrementCounter("ticksToRun", this.toRunThisTick.size());
+        this.runCollectedTicks(ticker);
+        profilerFiller.popPush("cleanup");
+        this.cleanupAfterTick();
+        profilerFiller.pop();
+    }
+
+    private void collectTicks(long time, int maxTicks, ProfilerFiller profiler) {
+        this.sortContainersToTick(time);
+        profiler.incrementCounter("containersToTick", this.containersToTick.size());
+        this.drainContainers(time, maxTicks);
+        this.rescheduleLeftoverContainers();
+    }
+
+    private void sortContainersToTick(long time) {
+        ObjectIterator<Long2LongMap.Entry> objectIterator = Long2LongMaps.fastIterator(this.nextTickForContainer);
+
+        while(objectIterator.hasNext()) {
+            Long2LongMap.Entry entry = objectIterator.next();
+            long l = entry.getLongKey();
+            long m = entry.getLongValue();
+            if (m <= time) {
+                LevelChunkTicks<T> levelChunkTicks = this.allContainers.get(l);
+                if (levelChunkTicks == null) {
+                    objectIterator.remove();
+                } else {
+                    ScheduledTick<T> scheduledTick = levelChunkTicks.peek();
+                    if (scheduledTick == null) {
+                        objectIterator.remove();
+                    } else if (scheduledTick.triggerTick() > time) {
+                        entry.setValue(scheduledTick.triggerTick());
+                    } else if (this.tickCheck.test(l)) {
+                        objectIterator.remove();
+                        this.containersToTick.add(levelChunkTicks);
+                    }
+                }
+            }
+        }
+
+    }
+
+    private void drainContainers(long time, int maxTicks) {
+        LevelChunkTicks<T> levelChunkTicks;
+        while(this.canScheduleMoreTicks(maxTicks) && (levelChunkTicks = this.containersToTick.poll()) != null) {
+            ScheduledTick<T> scheduledTick = levelChunkTicks.poll();
+            this.scheduleForThisTick(scheduledTick);
+            this.drainFromCurrentContainer(this.containersToTick, levelChunkTicks, time, maxTicks);
+            ScheduledTick<T> scheduledTick2 = levelChunkTicks.peek();
+            if (scheduledTick2 != null) {
+                if (scheduledTick2.triggerTick() <= time && this.canScheduleMoreTicks(maxTicks)) {
+                    this.containersToTick.add(levelChunkTicks);
+                } else {
+                    this.updateContainerScheduling(scheduledTick2);
+                }
+            }
+        }
+
+    }
+
+    private void rescheduleLeftoverContainers() {
+        for(LevelChunkTicks<T> levelChunkTicks : this.containersToTick) {
+            this.updateContainerScheduling(levelChunkTicks.peek());
+        }
+
+    }
+
+    private void updateContainerScheduling(ScheduledTick<T> tick) {
+        this.nextTickForContainer.put(ChunkPos.asLong(tick.pos()), tick.triggerTick());
+    }
+
+    private void drainFromCurrentContainer(Queue<LevelChunkTicks<T>> tickableChunkTickSchedulers, LevelChunkTicks<T> chunkTickScheduler, long tick, int maxTicks) {
+        if (this.canScheduleMoreTicks(maxTicks)) {
+            LevelChunkTicks<T> levelChunkTicks = tickableChunkTickSchedulers.peek();
+            ScheduledTick<T> scheduledTick = levelChunkTicks != null ? levelChunkTicks.peek() : null;
+
+            while(this.canScheduleMoreTicks(maxTicks)) {
+                ScheduledTick<T> scheduledTick2 = chunkTickScheduler.peek();
+                if (scheduledTick2 == null || scheduledTick2.triggerTick() > tick || scheduledTick != null && ScheduledTick.INTRA_TICK_DRAIN_ORDER.compare(scheduledTick2, scheduledTick) > 0) {
+                    break;
+                }
+
+                chunkTickScheduler.poll();
+                this.scheduleForThisTick(scheduledTick2);
+            }
+
+        }
+    }
+
+    private void scheduleForThisTick(ScheduledTick<T> tick) {
+        this.toRunThisTick.add(tick);
+    }
+
+    private boolean canScheduleMoreTicks(int maxTicks) {
+        return this.toRunThisTick.size() < maxTicks;
+    }
+
+    private void runCollectedTicks(BiConsumer<BlockPos, T> ticker) {
+        while(!this.toRunThisTick.isEmpty()) {
+            ScheduledTick<T> scheduledTick = this.toRunThisTick.poll();
+            if (!this.toRunThisTickSet.isEmpty()) {
+                this.toRunThisTickSet.remove(scheduledTick);
+            }
+
+            this.alreadyRunThisTick.add(scheduledTick);
+            ticker.accept(scheduledTick.pos(), scheduledTick.type());
+        }
+
+    }
+
+    private void cleanupAfterTick() {
+        this.toRunThisTick.clear();
+        this.containersToTick.clear();
+        this.alreadyRunThisTick.clear();
+        this.toRunThisTickSet.clear();
+    }
+
+    @Override
+    public boolean hasScheduledTick(BlockPos pos, T type) {
+        LevelChunkTicks<T> levelChunkTicks = this.allContainers.get(ChunkPos.asLong(pos));
+        return levelChunkTicks != null && levelChunkTicks.hasScheduledTick(pos, type);
+    }
+
+    @Override
+    public boolean willTickThisTick(BlockPos pos, T type) {
+        this.calculateTickSetIfNeeded();
+        return this.toRunThisTickSet.contains(ScheduledTick.probe(type, pos));
+    }
+
+    private void calculateTickSetIfNeeded() {
+        if (this.toRunThisTickSet.isEmpty() && !this.toRunThisTick.isEmpty()) {
+            this.toRunThisTickSet.addAll(this.toRunThisTick);
+        }
+
+    }
+
+    private void forContainersInArea(BoundingBox box, LevelTicks.PosAndContainerConsumer<T> visitor) {
+        int i = SectionPos.posToSectionCoord((double)box.minX());
+        int j = SectionPos.posToSectionCoord((double)box.minZ());
+        int k = SectionPos.posToSectionCoord((double)box.maxX());
+        int l = SectionPos.posToSectionCoord((double)box.maxZ());
+
+        for(int m = i; m <= k; ++m) {
+            for(int n = j; n <= l; ++n) {
+                long o = ChunkPos.asLong(m, n);
+                LevelChunkTicks<T> levelChunkTicks = this.allContainers.get(o);
+                if (levelChunkTicks != null) {
+                    visitor.accept(o, levelChunkTicks);
+                }
+            }
+        }
+
+    }
+
+    public void clearArea(BoundingBox box) {
+        Predicate<ScheduledTick<T>> predicate = (tick) -> {
+            return box.isInside(tick.pos());
+        };
+        this.forContainersInArea(box, (chunkPos, chunkTickScheduler) -> {
+            ScheduledTick<T> scheduledTick = chunkTickScheduler.peek();
+            chunkTickScheduler.removeIf(predicate);
+            ScheduledTick<T> scheduledTick2 = chunkTickScheduler.peek();
+            if (scheduledTick2 != scheduledTick) {
+                if (scheduledTick2 != null) {
+                    this.updateContainerScheduling(scheduledTick2);
+                } else {
+                    this.nextTickForContainer.remove(chunkPos);
+                }
+            }
+
+        });
+        this.alreadyRunThisTick.removeIf(predicate);
+        this.toRunThisTick.removeIf(predicate);
+    }
+
+    public void copyArea(BoundingBox box, Vec3i offset) {
+        this.copyAreaFrom(this, box, offset);
+    }
+
+    public void copyAreaFrom(LevelTicks<T> scheduler, BoundingBox box, Vec3i offset) {
+        List<ScheduledTick<T>> list = new ArrayList<>();
+        Predicate<ScheduledTick<T>> predicate = (tick) -> {
+            return box.isInside(tick.pos());
+        };
+        scheduler.alreadyRunThisTick.stream().filter(predicate).forEach(list::add);
+        scheduler.toRunThisTick.stream().filter(predicate).forEach(list::add);
+        scheduler.forContainersInArea(box, (chunkPos, chunkTickScheduler) -> {
+            chunkTickScheduler.getAll().filter(predicate).forEach(list::add);
+        });
+        LongSummaryStatistics longSummaryStatistics = list.stream().mapToLong(ScheduledTick::subTickOrder).summaryStatistics();
+        long l = longSummaryStatistics.getMin();
+        long m = longSummaryStatistics.getMax();
+        list.forEach((tick) -> {
+            this.schedule(new ScheduledTick<>(tick.type(), tick.pos().offset(offset), tick.triggerTick(), tick.priority(), tick.subTickOrder() - l + m + 1L));
+        });
+    }
+
+    @Override
+    public int count() {
+        return this.allContainers.values().stream().mapToInt(TickAccess::count).sum();
+    }
+
+    @FunctionalInterface
+    interface PosAndContainerConsumer<T> {
+        void accept(long chunkPos, LevelChunkTicks<T> chunkTickScheduler);
+    }
+}
